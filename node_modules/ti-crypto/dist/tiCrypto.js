/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 3);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function randomBytes(n) {
    if (n < 0)
        throw new Error("Cannot generate negative number of random bytes");
    return new Uint8Array(crypto.getRandomValues(new Uint8Array(n)).buffer);
}
exports.randomBytes = randomBytes;
function randomString(n) {
    return bytesToBase64(randomBytes(n), true);
}
exports.randomString = randomString;
function bytesToHex(binary) {
    return Array.prototype.map.call(binary, (x) => ('00' + x.toString(16)).slice(-2)).join('');
}
exports.bytesToHex = bytesToHex;
function hexToBytes(hex) {
    let binary = new Uint8Array(hex.length / 2);
    for (var i = 0, len = hex.length; i < len; i += 2) {
        binary[i / 2] = parseInt(hex.substr(i, 2), 16);
    }
    return binary;
}
exports.hexToBytes = hexToBytes;
function bytesToBase64(binary, urlSafe) {
    let base64 = btoa(String.fromCharCode(...binary));
    if (urlSafe)
        base64 = base64.replace(/\+/g, '-').replace(/\//g, '_').replace(/=+$/, '');
    return base64;
}
exports.bytesToBase64 = bytesToBase64;
function base64ToBytes(base64) {
    base64 = base64.replace(/\-/g, '+').replace(/_/g, '/').replace(/=+$/, '');
    base64 += '=='.substring(0, (3 * base64.length) % 4);
    let utf = atob(base64);
    let buf = new Uint8Array(utf.length);
    for (let i = 0; i < buf.length; i++)
        buf[i] = utf.charCodeAt(i);
    return buf;
}
exports.base64ToBytes = base64ToBytes;
function equalBuffers(buf1, buf2) {
    if (buf1.length != buf2.length)
        return false;
    let diff = 0;
    for (let i = 0; i < buf1.length; i++)
        diff = diff | (buf1[i] ^ buf2[i]);
    return diff == 0;
}
exports.equalBuffers = equalBuffers;
function sha256(data) {
    return new Promise((resolve, reject) => {
        crypto.subtle.digest({ name: "SHA-256" }, data.buffer).then(hashed => resolve(new Uint8Array(hashed)), () => reject("Unspecified hash error occurred."));
    });
}
exports.sha256 = sha256;


/***/ }),
/* 1 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const misc_1 = __webpack_require__(0);
const _der_1 = __webpack_require__(2);
exports.AES_IV_LENGTH = 16;
function genAESKey(len, algo) {
    return new Promise((resolve, reject) => {
        crypto.subtle.generateKey({
            name: algo,
            length: len * 8
        }, true, ["encrypt", "decrypt", "wrapKey", "unwrapKey"]).then(key => resolve(new AESKey(key)), err => reject(`AES gen key: CryptoSubtle error (${err}).`));
    });
}
exports.genAESKey = genAESKey;
function genCompositeAESKey(n, algo, size) {
    return new Promise((resolve, reject) => {
        size = size || 32;
        if (n < 2)
            throw new Error(`Must generate at least 2 sub-keys (given: ${n}).`);
        let keyImports = [];
        let master = new Uint8Array(size);
        for (let i = 0; i < n; i++) {
            let key = misc_1.randomBytes(size);
            for (let k = 0; k < size; k++) {
                master[k] = master[k] ^ key[k];
            }
            keyImports.push(importAESKey(key, algo));
        }
        Promise.all([
            importAESKey(master, algo),
            ...keyImports
        ]).then(aesKeys => {
            resolve({
                key: aesKeys[0],
                subKeys: aesKeys.slice(1)
            });
        }, err => reject(`Composite AES key gen: ${err}`));
    });
}
exports.genCompositeAESKey = genCompositeAESKey;
function importAESKey(key, algo) {
    return new Promise((resolve, reject) => {
        crypto.subtle.importKey("raw", key.buffer, {
            name: algo
        }, true, ["encrypt", "decrypt", "wrapKey", "unwrapKey"]).then(cryptoKey => {
            key.fill(0);
            resolve(new AESKey(cryptoKey));
        }, err => reject(`AES import key: CryptoSubtle error (${err}).`));
    });
}
exports.importAESKey = importAESKey;
class AESKey {
    encrypt(data, opts) {
        return new Promise((resolve, reject) => {
            opts = opts || {};
            opts.iv = opts.iv || misc_1.randomBytes(exports.AES_IV_LENGTH);
            if (opts.iv.length != exports.AES_IV_LENGTH)
                throw new Error(`AES encrypt: bad IV length (expected ${exports.AES_IV_LENGTH}, got ${opts.iv.length}).`);
            let encryptOpts = {
                name: this.algo,
                iv: opts.iv
            };
            if (this.algo === "AES-GCM")
                encryptOpts.tagLength = opts.tagLength ? opts.tagLength * 8 : 128;
            crypto.subtle.encrypt(encryptOpts, this.key, data.buffer).then(encrypted => {
                data.fill(0);
                let cipherText = new Uint8Array(encrypted);
                let tag;
                if (this.algo === "AES-GCM") {
                    let tagIndex = cipherText.byteLength - (encryptOpts.tagLength / 8);
                    tag = cipherText.subarray(tagIndex);
                    cipherText = cipherText.subarray(0, tagIndex);
                }
                let result = {
                    cipherText: opts.iv_and_e ? _der_1.concat(opts.iv, cipherText) : cipherText,
                    algo: this.algo
                };
                if (!opts.iv_and_e)
                    result.iv = opts.iv;
                if (tag)
                    result.tag = tag;
                resolve(result);
            }, err => reject(`AES encrypt: CryptoSubtle error (${err}).`));
        });
    }
    decrypt(data, iv, tag) {
        return new Promise((resolve, reject) => {
            if (!iv) {
                iv = data.subarray(0, exports.AES_IV_LENGTH);
                data = data.subarray(exports.AES_IV_LENGTH);
            }
            let decryptOpts = {
                name: this.algo,
                iv: iv.buffer
            };
            if (tag) {
                data = _der_1.concat(data, tag);
                decryptOpts.tagLength = tag.byteLength * 8;
            }
            else if (this.algo === "AES-GCM") {
                throw new Error("no tag provided for AES-GCM decryption");
            }
            crypto.subtle.decrypt(decryptOpts, this.key, data.buffer).then(clearText => resolve(new Uint8Array(clearText)), err => reject(`AES decrypt: CryptoSubtle error (${err}).`));
        });
    }
    wrapAESKey(key, opts) {
        return new Promise((resolve, reject) => {
            opts = opts || {};
            opts.iv = opts.iv || misc_1.randomBytes(exports.AES_IV_LENGTH);
            let encryptOpts = {
                name: this.algo,
                iv: opts.iv.buffer
            };
            if (this.algo === "AES-GCM")
                encryptOpts.tagLength = opts.tagLength ? opts.tagLength * 8 : 128;
            crypto.subtle.wrapKey("raw", key.key, this.key, encryptOpts).then(wrappedKey => {
                let cipherText = new Uint8Array(wrappedKey);
                let tag;
                if (this.algo === "AES-GCM") {
                    let tagIndex = cipherText.byteLength - (encryptOpts.tagLength / 8);
                    tag = cipherText.subarray(tagIndex);
                    cipherText = cipherText.subarray(0, tagIndex);
                }
                let result = {
                    cipherText: opts.iv_and_e ? _der_1.concat(opts.iv, cipherText) : cipherText,
                    algo: this.algo
                };
                if (!opts.iv_and_e)
                    result.iv = opts.iv;
                if (tag)
                    result.tag = tag;
                resolve(result);
                cipherText.fill(0);
            }, err => reject(`AES wrap key: CryptoSubtle error (${err}).`));
        });
    }
    unwrapAESKey(wrapped, opts) {
        return new Promise((resolve, reject) => {
            opts = opts || {};
            if (!opts.iv) {
                opts.iv = wrapped.subarray(0, exports.AES_IV_LENGTH);
                wrapped = wrapped.subarray(exports.AES_IV_LENGTH);
            }
            let decryptOpts = {
                name: this.algo,
                iv: opts.iv.buffer
            };
            if (opts.tag) {
                wrapped = _der_1.concat(wrapped, opts.tag);
                decryptOpts.tagLength = opts.tag.byteLength;
            }
            else if (this.algo === "AES-GCM") {
                throw new Error("no tag provided for AES-GCM unwrapping");
            }
            crypto.subtle.unwrapKey("raw", wrapped.buffer, this.key, decryptOpts, {
                name: opts.algo || "AES-CBC"
            }, opts.exportable ? true : false, [
                "encrypt",
                "decrypt",
                "wrapKey",
                "unwrapKey"
            ]).then(unwrapped => resolve(new AESKey(unwrapped)), err => reject(`AES unwrap key: CryptoSubtle error (${err}).`));
        });
    }
    export() {
        return new Promise((resolve, reject) => {
            crypto.subtle.exportKey("raw", this.key).then(raw => resolve(new Uint8Array(raw)), err => reject(`AES export key: CryptoSubtle error (${err}).`));
        });
    }
    constructor(key) {
        this.key = key;
        this.algo = key.algorithm.name;
    }
}
exports.AESKey = AESKey;


/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.EOC = 0x00;
exports.INTEGER = 0x02;
exports.BIT_STR = 0x03;
exports.OCT_STR = 0x04;
exports.SEQUENCE = 0x30;
function encodeToDER(type, buf) {
    let primitive;
    let lenOctets = 1;
    if (buf.length >= 0x80) {
        let nLenBytes = base256Len(buf.length);
        lenOctets += nLenBytes;
        primitive = new Uint8Array(1 + 1 + nLenBytes + buf.length);
        primitive[1] = 0x80 + nLenBytes;
        for (let n = buf.length, i = 1 + nLenBytes; n > 0; n = Math.floor(n / 256), i--)
            primitive[i] = n % 256;
    }
    else {
        primitive = new Uint8Array(1 + 1 + buf.length);
        primitive[1] = buf.length;
    }
    primitive[0] = type;
    primitive.set(buf, 1 + lenOctets);
    return primitive;
}
exports.encodeToDER = encodeToDER;
function base256Len(val) {
    return Math.ceil(Math.log2(val + 1) / 8);
}
exports.base256Len = base256Len;
function unsigned(int) {
    if (int.length == 0)
        throw new Error("Attempted to convert an empty Uint8Array to an unsigned buffer.");
    let firstNonzero = 0;
    while (int[firstNonzero] == 0)
        firstNonzero++;
    if (firstNonzero != 0)
        return int[firstNonzero] >= 0x80 ? int.slice(firstNonzero - 1) : int.slice(firstNonzero);
    else
        return int[firstNonzero] >= 0x80 ? new Uint8Array([0, ...int]) : int;
}
exports.unsigned = unsigned;
function concat(...bufs) {
    let tLen = 0;
    for (let i = 0; i < bufs.length; i++)
        tLen += bufs[i].length;
    let concatenated = new Uint8Array(tLen);
    let offset = 0;
    for (let i = 0; i < bufs.length; i++) {
        concatenated.set(bufs[i], offset);
        offset += bufs[i].length;
    }
    return concatenated;
}
exports.concat = concat;
function decodeDER(buf) {
    if (buf[0] == 0x00) {
        return {
            type: 0x00,
            content: new Uint8Array(0),
            remaining: buf.slice(1)
        };
    }
    let off = 0;
    let len = 0;
    if (buf[1] > 0x80) {
        off = 2 + (buf[1] - 0x80);
        len = decodeBase256Integer(buf.slice(2, off));
    }
    else if (buf[1] > 0 && buf[1] < 0x80) {
        off = 2;
        len = buf[1];
    }
    else {
        throw new Error(`Bad ASN length identifier (${buf[1]}).`);
    }
    return {
        type: buf[0],
        content: buf.slice(off, off + len),
        remaining: buf.slice(off + len)
    };
}
exports.decodeDER = decodeDER;
function decodeBase256Integer(buf, signed) {
    if (buf.length == 0)
        return 0;
    let value = (buf[0] >= 0x80 && signed) ? -Math.pow(256, buf.length) : 0;
    for (let i = buf.length - 1, sig = 1; i >= 0; i--, sig *= 256)
        value += buf[i] * sig;
    return value;
}
exports.decodeBase256Integer = decodeBase256Integer;


/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(0));
__export(__webpack_require__(1));
__export(__webpack_require__(4));
__export(__webpack_require__(5));
__export(__webpack_require__(6));


/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const misc_1 = __webpack_require__(0);
const aes_1 = __webpack_require__(1);
const _der_1 = __webpack_require__(2);
function convertOldKeyPair(old, pwd) {
    const version = new Uint8Array([0x02, 0x01, 0x00]);
    const rsaAlgo = new Uint8Array([
        0x30, 0x0D, 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86,
        0xF7, 0x0D, 0x01, 0x01, 0x01, 0x05, 0x00
    ]);
    return new Promise((resolve, reject) => {
        let oldWrapped = misc_1.base64ToBytes(old.key.privateKey.key);
        let salt = misc_1.base64ToBytes(old.key.privateKey.salt);
        let rounds = old.key.privateKey.iterations;
        let iv = misc_1.base64ToBytes(old.key.privateKey.iv);
        crypto.subtle.importKey("raw", pwd.buffer, {
            name: "PBKDF2"
        }, false, ["deriveKey"]).then(derivationKey => {
            pwd.fill(0);
            crypto.subtle.deriveKey({
                name: "PBKDF2",
                salt: salt.buffer,
                iterations: rounds,
                hash: { name: "SHA-256" }
            }, derivationKey, {
                name: "AES-CBC",
                length: 256,
            }, false, ["encrypt", "decrypt"]).then(aesKey => {
                crypto.subtle.decrypt({
                    name: "AES-CBC",
                    iv: iv.buffer
                }, aesKey, oldWrapped.buffer).then(oldUnwrapped => {
                    let decoder = new TextDecoder("utf-8");
                    let keyJson = JSON.parse(decoder.decode(new Uint8Array(oldUnwrapped)));
                    let keyInts = keyJson.map(elem => _der_1.encodeToDER(_der_1.INTEGER, _der_1.unsigned(misc_1.base64ToBytes(elem))));
                    keyInts.unshift(new Uint8Array([0x02, 0x01, 0x00]));
                    let privateKey = _der_1.encodeToDER(_der_1.OCT_STR, _der_1.encodeToDER(_der_1.SEQUENCE, _der_1.concat(...keyInts)));
                    let pkcs8Key = _der_1.encodeToDER(_der_1.SEQUENCE, _der_1.concat(version, rsaAlgo, privateKey));
                    iv = misc_1.randomBytes(16);
                    crypto.subtle.encrypt({
                        name: "AES-CBC",
                        iv: iv.buffer
                    }, aesKey, pkcs8Key.buffer).then(wrapped => resolve({
                        email: old.email,
                        public: old.key.publicKey,
                        private: {
                            encrypted: misc_1.bytesToBase64(new Uint8Array(wrapped)),
                            encoding: "pkcs8",
                            kdf: "PBKDF2:SHA-256",
                            rounds: rounds,
                            salt: misc_1.bytesToBase64(salt),
                            encAlgo: "AES-CBC",
                            encSize: 32,
                            iv: misc_1.bytesToBase64(iv)
                        }
                    }), err => reject(`CryptoSubtle failed to rewrap key (${err}).`));
                }, err => reject(`CryptoSubtle failed to unwrap key (${err}).`));
            }, err => reject(`CryptoSubtle failed to derive unwrapping/re-wrapping key (${err}).`));
        }, err => reject(`CryptoSubtle failed to create derivation key from password (${err}).`));
    }).catch(err => { throw new Error(`RSA convert deprecated key pair: ${err}`); });
}
exports.convertOldKeyPair = convertOldKeyPair;
function genRSAKeyPair(modLen, pubExp) {
    return new Promise((resolve, reject) => {
        crypto.subtle.generateKey({
            name: "RSA-PSS",
            modulusLength: modLen || 2048,
            publicExponent: pubExp || new Uint8Array([0x01, 0x00, 0x01]),
            hash: { name: "SHA-256" }
        }, true, ["sign", "verify"]).then(pssPair => {
            Promise.all([
                crypto.subtle.exportKey("spki", pssPair.publicKey),
                crypto.subtle.exportKey("pkcs8", pssPair.privateKey)
            ]).then(([rawPub, rawPriv]) => {
                const algo = {
                    name: "RSA-OAEP",
                    hash: { name: "SHA-256" }
                };
                Promise.all([
                    crypto.subtle.importKey("spki", rawPub, algo, true, ["encrypt", "wrapKey"]),
                    crypto.subtle.importKey("pkcs8", rawPriv, algo, true, ["decrypt", "unwrapKey"])
                ]).then(([oaepPub, oaepPriv]) => {
                    new Uint8Array(rawPriv).fill(0);
                    resolve({
                        public: new RSAPublic(pssPair.publicKey, oaepPub),
                        private: new RSAPrivate(pssPair.privateKey, oaepPriv)
                    });
                }, err => reject(`RSA gen key: CryptoSubtle failed to re-import keys as OAEP (${err}).`));
            }, err => reject(`RSA gen key: CryptoSubtle failed to export raw keys (${err}).`));
        }, err => reject(`RSA gen key: CryptoSubtle error (${err}).`));
    });
}
exports.genRSAKeyPair = genRSAKeyPair;
;
function genRSAKeyPairAndExport(pwd, modLen, pubExp) {
    return new Promise((resolve, reject) => {
        crypto.subtle.generateKey({
            name: "RSA-PSS",
            modulusLength: modLen || 2048,
            publicExponent: pubExp || new Uint8Array([0x01, 0x00, 0x01]),
            hash: { name: "SHA-256" }
        }, true, ["sign", "verify"]).then(keyPair => {
            exportRSAPrivate(keyPair.privateKey, pwd).then(extPriv => {
                exportRSAPublic(keyPair.publicKey).then(extPub => resolve({
                    public: extPub,
                    private: extPriv
                }), err => reject(`RSA gen key: ${err}`));
            }, err => reject(`RSA gen key: ${err}`));
        }, err => reject(`RSA gen key: CryptoSubtle error (${err}).`));
    });
}
exports.genRSAKeyPairAndExport = genRSAKeyPairAndExport;
;
function importRSAKeyPair(ext, pwd) {
    return Promise.all([
        importRSAPublic(ext.public),
        importRSAPrivate(ext.private, pwd)
    ]).then(([pubkey, privKey]) => {
        return {
            email: ext.email,
            public: pubkey,
            private: privKey
        };
    });
}
exports.importRSAKeyPair = importRSAKeyPair;
class RSAPublic {
    verify(data, sig) {
        return new Promise((resolve, reject) => {
            crypto.subtle.verify({
                name: "RSA-PSS",
                saltLength: sig.saltLength
            }, this.pss, misc_1.base64ToBytes(sig.signature).buffer, data.buffer).then(resolve, err => reject(`RSA verify: CryptoSubtle error (${err}).`));
        });
    }
    encrypt(clearText) {
        return new Promise((resolve, reject) => {
            crypto.subtle.encrypt({
                name: "RSA-OAEP",
            }, this.oaep, clearText.buffer).then(encrypted => resolve(new Uint8Array(encrypted)), err => reject(new Error(`RSA encrypt: CryptoSubtle error (${err}).`)));
        });
    }
    wrapAESKey(key) {
        return new Promise((resolve, reject) => {
            if (!key.key.extractable)
                throw new Error("AES key cannot be wrapped because it is not exportable.");
            crypto.subtle.wrapKey("raw", key.key, this.oaep, {
                name: "RSA-OAEP",
                hash: { name: "SHA-256" }
            }).then(wrapped => resolve(new Uint8Array(wrapped)), err => reject(`RSA wrap key: CryptoSubtle error (${err})`));
        });
    }
    export() {
        return exportRSAPublic(this.pss);
    }
    constructor(pss, oaep) {
        this.pss = pss;
        this.oaep = oaep;
    }
}
exports.RSAPublic = RSAPublic;
class RSAPrivate {
    sign(data, saltLen) {
        return new Promise((resolve, reject) => {
            saltLen = saltLen ? saltLen : 32;
            crypto.subtle.sign({
                name: "RSA-PSS",
                saltLength: saltLen
            }, this.pss, data.buffer).then(sig => resolve({
                signature: misc_1.bytesToBase64(new Uint8Array(sig)),
                saltLength: saltLen
            }), err => reject(new Error(`RSA sign: CryptoSubtle error (${err}).`)));
        });
    }
    signChallenge(challenge, saltLen) {
        return new Promise((resolve, reject) => {
            let serverToken = misc_1.base64ToBytes(challenge);
            let clientToken = misc_1.randomBytes(32);
            let dataToSign = new Uint8Array(serverToken.length + clientToken.length);
            dataToSign.set(serverToken, 0);
            dataToSign.set(clientToken, serverToken.length);
            this.sign(dataToSign, saltLen).then(sig => resolve({
                signature: sig.signature,
                serverToken: challenge,
                clientToken: misc_1.bytesToBase64(clientToken),
                saltLen: sig.saltLength
            }), reject);
        });
    }
    decrypt(cipherText) {
        return new Promise((resolve, reject) => {
            crypto.subtle.decrypt({
                name: "RSA-OAEP"
            }, this.oaep, cipherText.buffer).then(clearText => resolve(new Uint8Array(clearText)), err => reject(`RSA decrypt: CryptoSubtle error (${err}).`));
        });
    }
    unwrapAESKey(wrapped, algo, exportable) {
        return new Promise((resolve, reject) => {
            crypto.subtle.unwrapKey("raw", wrapped.buffer, this.oaep, {
                name: "RSA-OAEP",
                hash: { name: "SHA-256" }
            }, {
                name: algo
            }, exportable ? true : false, ["encrypt", "decrypt", "wrapKey", "unwrapKey"]).then(unwrapped => resolve(new aes_1.AESKey(unwrapped)), err => reject(`RSA unwrap key: CryptoSubtle error (${err}).`));
        });
    }
    export(password, rounds) {
        return exportRSAPrivate(this.pss, password, rounds);
    }
    extractPublic() {
        return new Promise((resolve, reject) => {
            crypto.subtle.exportKey("pkcs8", this.pss).then(pkcs8 => {
                let keySeq = _der_1.decodeDER(_der_1.decodeDER(_der_1.decodeDER(_der_1.decodeDER(_der_1.decodeDER(new Uint8Array(pkcs8)).content).remaining).remaining).content).content;
                let rsaVersion = _der_1.decodeDER(keySeq);
                let nBlock = _der_1.decodeDER(rsaVersion.remaining);
                let eBlock = _der_1.decodeDER(nBlock.remaining);
                let spki = makeSPKI(nBlock.content, eBlock.content);
                Promise.all([
                    crypto.subtle.importKey("spki", spki.buffer, {
                        name: "RSA-PSS",
                        hash: { name: "SHA-256" }
                    }, true, ["verify"]),
                    crypto.subtle.importKey("spki", spki.buffer, {
                        name: "RSA-OAEP",
                        hash: { name: "SHA-256" }
                    }, true, ["encrypt", "wrapKey"])
                ]).then(([pss, oaep]) => {
                    resolve(new RSAPublic(pss, oaep));
                    new Uint8Array(pkcs8).fill(0);
                }, err => {
                    reject(`CryptoSubtle failed to import SPKI public key (${err}).`);
                    new Uint8Array(pkcs8).fill(0);
                });
            }, err => reject(`CryptoSubtle failed to export private to PKCS8 (${err}).`));
        }).catch(err => { throw new Error(`RSA extract public: ${err}`); });
    }
    constructor(pss, oaep) {
        this.pss = pss;
        this.oaep = oaep;
    }
}
exports.RSAPrivate = RSAPrivate;
function importRSAPublic(ext) {
    return new Promise((resolve, reject) => {
        let spki = externalRSAPublicToSPKI(ext);
        Promise.all([
            crypto.subtle.importKey("spki", spki.buffer, {
                name: "RSA-PSS",
                hash: { name: "SHA-256" }
            }, true, ["verify"]),
            crypto.subtle.importKey("spki", spki.buffer, {
                name: "RSA-OAEP",
                hash: { name: "SHA-256" }
            }, true, ["encrypt", "wrapKey"])
        ]).then(([pss, oaep]) => resolve(new RSAPublic(pss, oaep)), err => reject(new Error(`RSA import public: CryptoSubtle error (${err}).`)));
    });
}
exports.importRSAPublic = importRSAPublic;
function importRSAPrivate(ext, pwd) {
    return new Promise((resolve, reject) => {
        crypto.subtle.importKey("raw", pwd.buffer, {
            name: "PBKDF2"
        }, false, ["deriveKey"]).then(derivationKey => {
            pwd.fill(0);
            let kdfAndHash = ext.kdf.split(":");
            crypto.subtle.deriveKey({
                name: kdfAndHash[0],
                salt: misc_1.base64ToBytes(ext.salt).buffer,
                iterations: ext.rounds,
                hash: { name: kdfAndHash[1] }
            }, derivationKey, {
                name: ext.encAlgo,
                length: ext.encSize * 8,
            }, false, ["unwrapKey"]).then(decryptionKey => {
                let encryptedPrivate = misc_1.base64ToBytes(ext.encrypted);
                let iv = misc_1.base64ToBytes(ext.iv).buffer;
                Promise.all([
                    crypto.subtle.unwrapKey(ext.encoding, encryptedPrivate, decryptionKey, {
                        name: ext.encAlgo,
                        iv: iv
                    }, {
                        name: "RSA-PSS",
                        hash: { name: "SHA-256" }
                    }, false, ["sign"]),
                    crypto.subtle.unwrapKey(ext.encoding, encryptedPrivate, decryptionKey, {
                        name: ext.encAlgo,
                        iv: iv
                    }, {
                        name: "RSA-OAEP",
                        hash: { name: "SHA-256" }
                    }, false, ["decrypt", "unwrapKey"])
                ]).then(([pss, oaep]) => {
                    resolve(new RSAPrivate(pss, oaep));
                }, err => reject(`CryptoSubtle failed to unwrap key (${err}).`));
            }, err => reject(`CryptoSubtle failed to derive unwrapping key (${err}).`));
        }, err => reject(`CryptoSubtle failed to create derivation key from password (${err}).`));
    }).catch(err => { throw new Error(`RSA import private: ${err}`); });
}
exports.importRSAPrivate = importRSAPrivate;
function exportRSAPublic(key) {
    return new Promise((resolve, reject) => {
        crypto.subtle.exportKey("spki", key).then(spki => resolve(spkiToExternalRSAPublic(new Uint8Array(spki))), err => reject(`RSA export public: CryptoSubtle error (${err}).`));
    });
}
function exportRSAPrivate(key, pwd, rounds) {
    return new Promise((resolve, reject) => {
        let salt = misc_1.randomBytes(16);
        let iv = misc_1.randomBytes(16);
        rounds = rounds || 20000;
        crypto.subtle.importKey("raw", pwd.buffer, { name: "PBKDF2" }, false, ["deriveKey"]).then(derivationKey => {
            pwd.fill(0);
            crypto.subtle.deriveKey({
                name: "PBKDF2",
                salt: salt.buffer,
                iterations: rounds,
                hash: { name: "SHA-256" }
            }, derivationKey, {
                name: "AES-CBC",
                length: 256,
            }, false, ["wrapKey"]).then(wrappingKey => {
                crypto.subtle.wrapKey("pkcs8", key, wrappingKey, {
                    name: "AES-CBC",
                    iv: iv.buffer
                }).then(wrappedPrivate => {
                    resolve({
                        encrypted: misc_1.bytesToBase64(new Uint8Array(wrappedPrivate)),
                        encoding: "pkcs8",
                        kdf: "PBKDF2:SHA-256",
                        rounds: rounds,
                        salt: misc_1.bytesToBase64(salt),
                        encAlgo: "AES-CBC",
                        encSize: 32,
                        iv: misc_1.bytesToBase64(iv)
                    });
                }, err => reject(`CryptoSubtle failed to wrap key (${err}).`));
            }, err => reject(`CryptoSubtle failed to derive wrapping key (${err}).`));
        }, err => reject(`CryptoSubtle failed to create derivation key from password (${err}).`));
    }).catch(err => { throw new Error(`RSA export private: ${err}`); });
}
function spkiToExternalRSAPublic(spki) {
    let rootSeq = _der_1.decodeDER(spki);
    let keyAlgo = _der_1.decodeDER(rootSeq.content);
    let bitStr = _der_1.decodeDER(keyAlgo.remaining);
    let pubKey = _der_1.decodeDER(bitStr.content.slice(1));
    let modulus = _der_1.decodeDER(pubKey.content);
    let publicExponent = _der_1.decodeDER(modulus.remaining);
    return {
        modulus: misc_1.bytesToBase64(modulus.content),
        publicExponent: misc_1.bytesToBase64(publicExponent.content)
    };
}
function externalRSAPublicToSPKI(ext) {
    return makeSPKI(misc_1.base64ToBytes(ext.modulus), misc_1.base64ToBytes(ext.publicExponent));
}
function makeSPKI(n, e) {
    n = _der_1.encodeToDER(_der_1.INTEGER, _der_1.unsigned(n));
    e = _der_1.encodeToDER(_der_1.INTEGER, _der_1.unsigned(e));
    let pubKey = _der_1.encodeToDER(_der_1.SEQUENCE, _der_1.concat(n, e));
    let preEOC = new Uint8Array(1 + pubKey.length);
    preEOC[0] = _der_1.EOC;
    preEOC.set(pubKey, 1);
    const rsaAlgoID = new Uint8Array([
        0x30, 0x0D, 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86,
        0xF7, 0x0D, 0x01, 0x01, 0x01, 0x05, 0x00
    ]);
    let bitStr = _der_1.encodeToDER(_der_1.BIT_STR, preEOC);
    return _der_1.encodeToDER(_der_1.SEQUENCE, _der_1.concat(rsaAlgoID, bitStr));
}


/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
function genECDHPair(curve, exportable) {
    return new Promise((resolve, reject) => {
        return crypto.subtle.generateKey({
            name: "ECDH",
            namedCurve: curve
        }, exportable || false, ["deriveKey", "deriveBits"]).then((pair) => {
            return {
                public: new ECDHPublic(pair.publicKey, curve),
                private: new ECDHPrivate(pair.privateKey, curve)
            };
        });
    });
}
exports.genECDHPair = genECDHPair;
function importECDHPublic(data, format, curve, exportable) {
    return new Promise((res, rej) => {
        return crypto.subtle.importKey(format, data, {
            name: "ECDH",
            namedCurve: curve
        }, exportable || false, []).then(key => new ECDHPublic(key, curve));
    });
}
exports.importECDHPublic = importECDHPublic;
class ECDHPublic {
    constructor(key, curve) {
        this.key = key;
        this.curve = curve;
    }
    export(format) {
        return new Promise((res, rej) => {
            return crypto.subtle.exportKey(format, this.key)
                .then(buf => new Uint8Array(buf));
        });
    }
}
exports.ECDHPublic = ECDHPublic;
class ECDHPrivate {
    constructor(key, curve) {
        this.key = key;
        this.curve = curve;
    }
    deriveBytes(pub, bytes) {
        return new Promise((res, rej) => {
            if (pub.curve !== this.curve)
                throw new Error(`tried to use ${pub.curve} ECDH public with ${this.curve} private`);
            crypto.subtle.deriveBits({
                name: "ECDH",
                namedCurve: this.curve,
                public: pub.key
            }, this.key, bytes * 8).then(buf => res(new Uint8Array(buf)), err => rej(`ECDH deriveBytes: CryptoSubtle error (${err}).`));
        });
    }
}
exports.ECDHPrivate = ECDHPrivate;


/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const misc_1 = __webpack_require__(0);
function genPBKDF2Key(exportable) {
    return new Promise((res, rej) => {
        crypto.subtle.generateKey({
            name: "PBKDF2"
        }, exportable || false, ["deriveKey", "deriveBits"]).then(key => res(new PBKDF2Key(key)), err => rej(`PBKDF2 gen key: CryptoSubtle error (${err}).`));
    });
}
exports.genPBKDF2Key = genPBKDF2Key;
function importPBKDF2Key(raw, exportable) {
    return new Promise((res, rej) => {
        crypto.subtle.importKey("raw", raw.buffer, {
            name: "PBKDF2"
        }, exportable || false, ["deriveKey", "deriveBits"]).then(key => res(new PBKDF2Key(key)), err => rej(`PBKDF2 import key: CryptoSubtle error (${err}).`));
    });
}
exports.importPBKDF2Key = importPBKDF2Key;
class PBKDF2Key {
    constructor(key) {
        this.key = key;
    }
    deriveBytes(bytes, iterations, hashAlgo, salt) {
        return new Promise((res, rej) => {
            crypto.subtle.deriveBits({
                name: "PBKDF2",
                salt: salt || misc_1.randomBytes(16).buffer,
                iterations: iterations,
                hash: { name: hashAlgo }
            }, this.key, bytes * 8).then(buf => res(new Uint8Array(buf)), err => rej(`AES deriveBytes: CryptoSubtle error (${err}).`));
        });
    }
}
exports.PBKDF2Key = PBKDF2Key;


/***/ })
/******/ ]);