(function(a){function b(d){if(c[d])return c[d].exports;var e=c[d]={i:d,l:!1,exports:{}};return a[d].call(e.exports,e,e.exports,b),e.l=!0,e.exports}var c={};return b.m=a,b.c=c,b.d=function(a,c,d){b.o(a,c)||Object.defineProperty(a,c,{configurable:!1,enumerable:!0,get:d})},b.n=function(a){var c=a&&a.__esModule?function(){return a['default']}:function(){return a};return b.d(c,'a',c),c},b.o=function(a,b){return Object.prototype.hasOwnProperty.call(a,b)},b.p='',b(b.s=3)})([function(a,b){'use strict';function c(a){if(0>a)throw new Error('Cannot generate negative number of random bytes');return new Uint8Array(crypto.getRandomValues(new Uint8Array(a)).buffer)}function d(a,b){let c=btoa(String.fromCharCode(...a));return b&&(c=c.replace(/\+/g,'-').replace(/\//g,'_').replace(/=+$/,'')),c}Object.defineProperty(b,'__esModule',{value:!0}),b.randomBytes=c,b.randomString=function(a){return d(c(a),!0)},b.bytesToHex=function(a){return Array.prototype.map.call(a,(a)=>('00'+a.toString(16)).slice(-2)).join('')},b.hexToBytes=function(a){let b=new Uint8Array(a.length/2);for(var c=0,d=a.length;c<d;c+=2)b[c/2]=parseInt(a.substr(c,2),16);return b},b.bytesToBase64=d,b.base64ToBytes=function(a){a=a.replace(/\-/g,'+').replace(/_/g,'/').replace(/=+$/,''),a+='=='.substring(0,3*a.length%4);let b=atob(a),c=new Uint8Array(b.length);for(let d=0;d<c.length;d++)c[d]=b.charCodeAt(d);return c},b.equalBuffers=function(a,b){if(a.length!=b.length)return!1;let c=0;for(let d=0;d<a.length;d++)c|=a[d]^b[d];return 0==c},b.sha256=function(a){return new Promise((b,c)=>{crypto.subtle.digest({name:'SHA-256'},a.buffer).then((a)=>b(new Uint8Array(a)),()=>c('Unspecified hash error occurred.'))})}},function(a,b,c){'use strict';function d(a,b){return new Promise((c,d)=>{crypto.subtle.importKey('raw',a.buffer,{name:b},!0,['encrypt','decrypt','wrapKey','unwrapKey']).then((b)=>{a.fill(0),c(new g(b))},(a)=>d(`AES import key: CryptoSubtle error (${a}).`))})}Object.defineProperty(b,'__esModule',{value:!0});const e=c(0),f=c(2);b.AES_IV_LENGTH=16,b.genAESKey=function(a,b){return new Promise((c,d)=>{crypto.subtle.generateKey({name:b,length:8*a},!0,['encrypt','decrypt','wrapKey','unwrapKey']).then((a)=>c(new g(a)),(a)=>d(`AES gen key: CryptoSubtle error (${a}).`))})},b.genCompositeAESKey=function(a,b,c){return new Promise((f,g)=>{if(c=c||32,2>a)throw new Error(`Must generate at least 2 sub-keys (given: ${a}).`);let h=[],i=new Uint8Array(c);for(let j,k=0;k<a;k++){j=e.randomBytes(c);for(let a=0;a<c;a++)i[a]^=j[a];h.push(d(j,b))}Promise.all([d(i,b),...h]).then((a)=>{f({key:a[0],subKeys:a.slice(1)})},(a)=>g(`Composite AES key gen: ${a}`))})},b.importAESKey=d;class g{encrypt(a,c){return new Promise((d,g)=>{if(c=c||{},c.iv=c.iv||e.randomBytes(b.AES_IV_LENGTH),c.iv.length!=b.AES_IV_LENGTH)throw new Error(`AES encrypt: bad IV length (expected ${b.AES_IV_LENGTH}, got ${c.iv.length}).`);let h={name:this.algo,iv:c.iv};'AES-GCM'===this.algo&&(h.tagLength=c.tagLength?8*c.tagLength:128),crypto.subtle.encrypt(h,this.key,a.buffer).then((b)=>{a.fill(0);let e,g=new Uint8Array(b);if('AES-GCM'===this.algo){let a=g.byteLength-h.tagLength/8;e=g.subarray(a),g=g.subarray(0,a)}let i={cipherText:c.iv_and_e?f.concat(c.iv,g):g,algo:this.algo};c.iv_and_e||(i.iv=c.iv),e&&(i.tag=e),d(i)},(a)=>g(`AES encrypt: CryptoSubtle error (${a}).`))})}decrypt(a,c,d){return new Promise((e,g)=>{c||(c=a.subarray(0,b.AES_IV_LENGTH),a=a.subarray(b.AES_IV_LENGTH));let h={name:this.algo,iv:c.buffer};if(d)a=f.concat(a,d),h.tagLength=8*d.byteLength;else if('AES-GCM'===this.algo)throw new Error('no tag provided for AES-GCM decryption');crypto.subtle.decrypt(h,this.key,a.buffer).then((a)=>e(new Uint8Array(a)),(a)=>g(`AES decrypt: CryptoSubtle error (${a}).`))})}wrapAESKey(a,c){return new Promise((d,g)=>{c=c||{},c.iv=c.iv||e.randomBytes(b.AES_IV_LENGTH);let h={name:this.algo,iv:c.iv.buffer};'AES-GCM'===this.algo&&(h.tagLength=c.tagLength?8*c.tagLength:128),crypto.subtle.wrapKey('raw',a.key,this.key,h).then((a)=>{let b,e=new Uint8Array(a);if('AES-GCM'===this.algo){let a=e.byteLength-h.tagLength/8;b=e.subarray(a),e=e.subarray(0,a)}let g={cipherText:c.iv_and_e?f.concat(c.iv,e):e,algo:this.algo};c.iv_and_e||(g.iv=c.iv),b&&(g.tag=b),d(g),e.fill(0)},(a)=>g(`AES wrap key: CryptoSubtle error (${a}).`))})}unwrapAESKey(a,c){return new Promise((d,e)=>{c=c||{},c.iv||(c.iv=a.subarray(0,b.AES_IV_LENGTH),a=a.subarray(b.AES_IV_LENGTH));let h={name:this.algo,iv:c.iv.buffer};if(c.tag)a=f.concat(a,c.tag),h.tagLength=c.tag.byteLength;else if('AES-GCM'===this.algo)throw new Error('no tag provided for AES-GCM unwrapping');crypto.subtle.unwrapKey('raw',a.buffer,this.key,h,{name:c.algo||'AES-CBC'},!!c.exportable,['encrypt','decrypt','wrapKey','unwrapKey']).then((a)=>d(new g(a)),(a)=>e(`AES unwrap key: CryptoSubtle error (${a}).`))})}export(){return new Promise((a,b)=>{crypto.subtle.exportKey('raw',this.key).then((b)=>a(new Uint8Array(b)),(a)=>b(`AES export key: CryptoSubtle error (${a}).`))})}constructor(a){this.key=a,this.algo=a.algorithm.name}}b.AESKey=g},function(a,b){'use strict';function c(a){return Math.ceil(Math.log2(a+1)/8)}function d(a,b){if(0==a.length)return 0;let c=128<=a[0]&&b?-Math.pow(256,a.length):0;for(let d=a.length-1,e=1;0<=d;d--,e*=256)c+=a[d]*e;return c}Object.defineProperty(b,'__esModule',{value:!0}),b.EOC=0,b.INTEGER=2,b.BIT_STR=3,b.OCT_STR=4,b.SEQUENCE=48,b.encodeToDER=function(a,b){let d,e=1;if(128<=b.length){let a=c(b.length);e+=a,d=new Uint8Array(2+a+b.length),d[1]=128+a;for(let c=b.length,e=1+a;0<c;c=Math.floor(c/256),e--)d[e]=c%256}else d=new Uint8Array(2+b.length),d[1]=b.length;return d[0]=a,d.set(b,1+e),d},b.base256Len=c,b.unsigned=function(a){if(0==a.length)throw new Error('Attempted to convert an empty Uint8Array to an unsigned buffer.');let b=0;for(;0==a[b];)b++;return 0==b?128<=a[b]?new Uint8Array([0,...a]):a:128<=a[b]?a.slice(b-1):a.slice(b)},b.concat=function(...a){let b=0;for(let c=0;c<a.length;c++)b+=a[c].length;let c=new Uint8Array(b),d=0;for(let b=0;b<a.length;b++)c.set(a[b],d),d+=a[b].length;return c},b.decodeDER=function(a){if(0==a[0])return{type:0,content:new Uint8Array(0),remaining:a.slice(1)};let b=0,c=0;if(128<a[1])b=2+(a[1]-128),c=d(a.slice(2,b));else if(0<a[1]&&128>a[1])b=2,c=a[1];else throw new Error(`Bad ASN length identifier (${a[1]}).`);return{type:a[0],content:a.slice(b,b+c),remaining:a.slice(b+c)}},b.decodeBase256Integer=d},function(a,b,c){'use strict';function d(a){for(var c in a)b.hasOwnProperty(c)||(b[c]=a[c])}Object.defineProperty(b,'__esModule',{value:!0}),d(c(0)),d(c(1)),d(c(4)),d(c(5)),d(c(6))},function(a,b,c){'use strict';function d(a){return new Promise((b,c)=>{let d=i(a);Promise.all([crypto.subtle.importKey('spki',d.buffer,{name:'RSA-PSS',hash:{name:'SHA-256'}},!0,['verify']),crypto.subtle.importKey('spki',d.buffer,{name:'RSA-OAEP',hash:{name:'SHA-256'}},!0,['encrypt','wrapKey'])]).then(([a,c])=>b(new n(a,c)),(a)=>c(new Error(`RSA import public: CryptoSubtle error (${a}).`)))})}function e(a,b){return new Promise((c,d)=>{crypto.subtle.importKey('raw',b.buffer,{name:'PBKDF2'},!1,['deriveKey']).then((e)=>{b.fill(0);let f=a.kdf.split(':');crypto.subtle.deriveKey({name:f[0],salt:k.base64ToBytes(a.salt).buffer,iterations:a.rounds,hash:{name:f[1]}},e,{name:a.encAlgo,length:8*a.encSize},!1,['unwrapKey']).then((b)=>{let e=k.base64ToBytes(a.encrypted),f=k.base64ToBytes(a.iv).buffer;Promise.all([crypto.subtle.unwrapKey(a.encoding,e,b,{name:a.encAlgo,iv:f},{name:'RSA-PSS',hash:{name:'SHA-256'}},!1,['sign']),crypto.subtle.unwrapKey(a.encoding,e,b,{name:a.encAlgo,iv:f},{name:'RSA-OAEP',hash:{name:'SHA-256'}},!1,['decrypt','unwrapKey'])]).then(([a,b])=>{c(new o(a,b))},(a)=>d(`CryptoSubtle failed to unwrap key (${a}).`))},(a)=>d(`CryptoSubtle failed to derive unwrapping key (${a}).`))},(a)=>d(`CryptoSubtle failed to create derivation key from password (${a}).`))}).catch((a)=>{throw new Error(`RSA import private: ${a}`)})}function f(a){return new Promise((b,c)=>{crypto.subtle.exportKey('spki',a).then((a)=>b(h(new Uint8Array(a))),(a)=>c(`RSA export public: CryptoSubtle error (${a}).`))})}function g(a,b,c){return new Promise((d,e)=>{let f=k.randomBytes(16),g=k.randomBytes(16);c=c||2e4,crypto.subtle.importKey('raw',b.buffer,{name:'PBKDF2'},!1,['deriveKey']).then((h)=>{b.fill(0),crypto.subtle.deriveKey({name:'PBKDF2',salt:f.buffer,iterations:c,hash:{name:'SHA-256'}},h,{name:'AES-CBC',length:256},!1,['wrapKey']).then((b)=>{crypto.subtle.wrapKey('pkcs8',a,b,{name:'AES-CBC',iv:g.buffer}).then((a)=>{d({encrypted:k.bytesToBase64(new Uint8Array(a)),encoding:'pkcs8',kdf:'PBKDF2:SHA-256',rounds:c,salt:k.bytesToBase64(f),encAlgo:'AES-CBC',encSize:32,iv:k.bytesToBase64(g)})},(a)=>e(`CryptoSubtle failed to wrap key (${a}).`))},(a)=>e(`CryptoSubtle failed to derive wrapping key (${a}).`))},(a)=>e(`CryptoSubtle failed to create derivation key from password (${a}).`))}).catch((a)=>{throw new Error(`RSA export private: ${a}`)})}function h(a){let b=m.decodeDER(a),c=m.decodeDER(b.content),d=m.decodeDER(c.remaining),e=m.decodeDER(d.content.slice(1)),f=m.decodeDER(e.content),g=m.decodeDER(f.remaining);return{modulus:k.bytesToBase64(f.content),publicExponent:k.bytesToBase64(g.content)}}function i(a){return j(k.base64ToBytes(a.modulus),k.base64ToBytes(a.publicExponent))}function j(a,b){a=m.encodeToDER(m.INTEGER,m.unsigned(a)),b=m.encodeToDER(m.INTEGER,m.unsigned(b));let c=m.encodeToDER(m.SEQUENCE,m.concat(a,b)),d=new Uint8Array(1+c.length);d[0]=m.EOC,d.set(c,1);const e=new Uint8Array([48,13,6,9,42,134,72,134,247,13,1,1,1,5,0]);let f=m.encodeToDER(m.BIT_STR,d);return m.encodeToDER(m.SEQUENCE,m.concat(e,f))}Object.defineProperty(b,'__esModule',{value:!0});const k=c(0),l=c(1),m=c(2);b.convertOldKeyPair=function(a,b){const c=new Uint8Array([2,1,0]),d=new Uint8Array([48,13,6,9,42,134,72,134,247,13,1,1,1,5,0]);return new Promise((e,f)=>{let g=k.base64ToBytes(a.key.privateKey.key),h=k.base64ToBytes(a.key.privateKey.salt),i=a.key.privateKey.iterations,j=k.base64ToBytes(a.key.privateKey.iv);crypto.subtle.importKey('raw',b.buffer,{name:'PBKDF2'},!1,['deriveKey']).then((l)=>{b.fill(0),crypto.subtle.deriveKey({name:'PBKDF2',salt:h.buffer,iterations:i,hash:{name:'SHA-256'}},l,{name:'AES-CBC',length:256},!1,['encrypt','decrypt']).then((b)=>{crypto.subtle.decrypt({name:'AES-CBC',iv:j.buffer},b,g.buffer).then((g)=>{let l=new TextDecoder('utf-8'),n=JSON.parse(l.decode(new Uint8Array(g))),o=n.map((a)=>m.encodeToDER(m.INTEGER,m.unsigned(k.base64ToBytes(a))));o.unshift(new Uint8Array([2,1,0]));let p=m.encodeToDER(m.OCT_STR,m.encodeToDER(m.SEQUENCE,m.concat(...o))),q=m.encodeToDER(m.SEQUENCE,m.concat(c,d,p));j=k.randomBytes(16),crypto.subtle.encrypt({name:'AES-CBC',iv:j.buffer},b,q.buffer).then((b)=>e({email:a.email,public:a.key.publicKey,private:{encrypted:k.bytesToBase64(new Uint8Array(b)),encoding:'pkcs8',kdf:'PBKDF2:SHA-256',rounds:i,salt:k.bytesToBase64(h),encAlgo:'AES-CBC',encSize:32,iv:k.bytesToBase64(j)}}),(a)=>f(`CryptoSubtle failed to rewrap key (${a}).`))},(a)=>f(`CryptoSubtle failed to unwrap key (${a}).`))},(a)=>f(`CryptoSubtle failed to derive unwrapping/re-wrapping key (${a}).`))},(a)=>f(`CryptoSubtle failed to create derivation key from password (${a}).`))}).catch((a)=>{throw new Error(`RSA convert deprecated key pair: ${a}`)})},b.genRSAKeyPair=function(a,b){return new Promise((c,d)=>{crypto.subtle.generateKey({name:'RSA-PSS',modulusLength:a||2048,publicExponent:b||new Uint8Array([1,0,1]),hash:{name:'SHA-256'}},!0,['sign','verify']).then((a)=>{Promise.all([crypto.subtle.exportKey('spki',a.publicKey),crypto.subtle.exportKey('pkcs8',a.privateKey)]).then(([b,e])=>{const f={name:'RSA-OAEP',hash:{name:'SHA-256'}};Promise.all([crypto.subtle.importKey('spki',b,f,!0,['encrypt','wrapKey']),crypto.subtle.importKey('pkcs8',e,f,!0,['decrypt','unwrapKey'])]).then(([b,d])=>{new Uint8Array(e).fill(0),c({public:new n(a.publicKey,b),private:new o(a.privateKey,d)})},(a)=>d(`RSA gen key: CryptoSubtle failed to re-import keys as OAEP (${a}).`))},(a)=>d(`RSA gen key: CryptoSubtle failed to export raw keys (${a}).`))},(a)=>d(`RSA gen key: CryptoSubtle error (${a}).`))})};b.genRSAKeyPairAndExport=function(a,b,c){return new Promise((d,e)=>{crypto.subtle.generateKey({name:'RSA-PSS',modulusLength:b||2048,publicExponent:c||new Uint8Array([1,0,1]),hash:{name:'SHA-256'}},!0,['sign','verify']).then((b)=>{g(b.privateKey,a).then((a)=>{f(b.publicKey).then((b)=>d({public:b,private:a}),(a)=>e(`RSA gen key: ${a}`))},(a)=>e(`RSA gen key: ${a}`))},(a)=>e(`RSA gen key: CryptoSubtle error (${a}).`))})};b.importRSAKeyPair=function(a,b){return Promise.all([d(a.public),e(a.private,b)]).then(([b,c])=>({email:a.email,public:b,private:c}))};class n{verify(a,b){return new Promise((c,d)=>{crypto.subtle.verify({name:'RSA-PSS',saltLength:b.saltLength},this.pss,k.base64ToBytes(b.signature).buffer,a.buffer).then(c,(a)=>d(`RSA verify: CryptoSubtle error (${a}).`))})}encrypt(a){return new Promise((b,c)=>{crypto.subtle.encrypt({name:'RSA-OAEP'},this.oaep,a.buffer).then((a)=>b(new Uint8Array(a)),(a)=>c(new Error(`RSA encrypt: CryptoSubtle error (${a}).`)))})}wrapAESKey(a){return new Promise((b,c)=>{if(!a.key.extractable)throw new Error('AES key cannot be wrapped because it is not exportable.');crypto.subtle.wrapKey('raw',a.key,this.oaep,{name:'RSA-OAEP',hash:{name:'SHA-256'}}).then((a)=>b(new Uint8Array(a)),(a)=>c(`RSA wrap key: CryptoSubtle error (${a})`))})}export(){return f(this.pss)}constructor(a,b){this.pss=a,this.oaep=b}}b.RSAPublic=n;class o{sign(a,b){return new Promise((c,d)=>{b=b?b:32,crypto.subtle.sign({name:'RSA-PSS',saltLength:b},this.pss,a.buffer).then((a)=>c({signature:k.bytesToBase64(new Uint8Array(a)),saltLength:b}),(a)=>d(new Error(`RSA sign: CryptoSubtle error (${a}).`)))})}signChallenge(a,b){return new Promise((c,d)=>{let e=k.base64ToBytes(a),f=k.randomBytes(32),g=new Uint8Array(e.length+f.length);g.set(e,0),g.set(f,e.length),this.sign(g,b).then((b)=>c({signature:b.signature,serverToken:a,clientToken:k.bytesToBase64(f),saltLen:b.saltLength}),d)})}decrypt(a){return new Promise((b,c)=>{crypto.subtle.decrypt({name:'RSA-OAEP'},this.oaep,a.buffer).then((a)=>b(new Uint8Array(a)),(a)=>c(`RSA decrypt: CryptoSubtle error (${a}).`))})}unwrapAESKey(a,b,c){return new Promise((d,e)=>{crypto.subtle.unwrapKey('raw',a.buffer,this.oaep,{name:'RSA-OAEP',hash:{name:'SHA-256'}},{name:b},!!c,['encrypt','decrypt','wrapKey','unwrapKey']).then((a)=>d(new l.AESKey(a)),(a)=>e(`RSA unwrap key: CryptoSubtle error (${a}).`))})}export(a,b){return g(this.pss,a,b)}extractPublic(){return new Promise((a,b)=>{crypto.subtle.exportKey('pkcs8',this.pss).then((c)=>{let d=m.decodeDER(m.decodeDER(m.decodeDER(m.decodeDER(m.decodeDER(new Uint8Array(c)).content).remaining).remaining).content).content,e=m.decodeDER(d),f=m.decodeDER(e.remaining),g=m.decodeDER(f.remaining),h=j(f.content,g.content);Promise.all([crypto.subtle.importKey('spki',h.buffer,{name:'RSA-PSS',hash:{name:'SHA-256'}},!0,['verify']),crypto.subtle.importKey('spki',h.buffer,{name:'RSA-OAEP',hash:{name:'SHA-256'}},!0,['encrypt','wrapKey'])]).then(([b,d])=>{a(new n(b,d)),new Uint8Array(c).fill(0)},(a)=>{b(`CryptoSubtle failed to import SPKI public key (${a}).`),new Uint8Array(c).fill(0)})},(a)=>b(`CryptoSubtle failed to export private to PKCS8 (${a}).`))}).catch((a)=>{throw new Error(`RSA extract public: ${a}`)})}constructor(a,b){this.pss=a,this.oaep=b}}b.RSAPrivate=o,b.importRSAPublic=d,b.importRSAPrivate=e},function(a,b){'use strict';Object.defineProperty(b,'__esModule',{value:!0}),b.genECDHPair=function(a,b){return new Promise(()=>crypto.subtle.generateKey({name:'ECDH',namedCurve:a},b||!1,['deriveKey','deriveBits']).then((b)=>({public:new c(b.publicKey,a),private:new d(b.privateKey,a)})))},b.importECDHPublic=function(a,b,d,e){return new Promise(()=>crypto.subtle.importKey(b,a,{name:'ECDH',namedCurve:d},e||!1,[]).then((a)=>new c(a,d)))};class c{constructor(a,b){this.key=a,this.curve=b}export(a){return new Promise(()=>crypto.subtle.exportKey(a,this.key).then((a)=>new Uint8Array(a)))}}b.ECDHPublic=c;class d{constructor(a,b){this.key=a,this.curve=b}deriveBytes(a,b){return new Promise((c,d)=>{if(a.curve!==this.curve)throw new Error(`tried to use ${a.curve} ECDH public with ${this.curve} private`);crypto.subtle.deriveBits({name:'ECDH',namedCurve:this.curve,public:a.key},this.key,8*b).then((a)=>c(new Uint8Array(a)),(a)=>d(`ECDH deriveBytes: CryptoSubtle error (${a}).`))})}}b.ECDHPrivate=d},function(a,b,c){'use strict';Object.defineProperty(b,'__esModule',{value:!0});const d=c(0);b.genPBKDF2Key=function(a){return new Promise((b,c)=>{crypto.subtle.generateKey({name:'PBKDF2'},a||!1,['deriveKey','deriveBits']).then((a)=>b(new e(a)),(a)=>c(`PBKDF2 gen key: CryptoSubtle error (${a}).`))})},b.importPBKDF2Key=function(a,b){return new Promise((c,d)=>{crypto.subtle.importKey('raw',a.buffer,{name:'PBKDF2'},b||!1,['deriveKey','deriveBits']).then((a)=>c(new e(a)),(a)=>d(`PBKDF2 import key: CryptoSubtle error (${a}).`))})};class e{constructor(a){this.key=a}deriveBytes(a,b,c,e){return new Promise((f,g)=>{crypto.subtle.deriveBits({name:'PBKDF2',salt:e||d.randomBytes(16).buffer,iterations:b,hash:{name:c}},this.key,8*a).then((a)=>f(new Uint8Array(a)),(a)=>g(`AES deriveBytes: CryptoSubtle error (${a}).`))})}}b.PBKDF2Key=e}]);