declare namespace tiCrypto {
    export function randomBytes(n: number): Uint8Array;
    export function randomString(n: number): string;
    export function bytesToHex(binary: Uint8Array): string;
    export function hexToBytes(hex: string): Uint8Array;
    export function bytesToBase64(binary: Uint8Array, urlSafe?: boolean): string;
    export function base64ToBytes(base64: string): Uint8Array;
    export function equalBuffers(buf1: Uint8Array, buf2: Uint8Array): boolean;
    export function sha256(data: Uint8Array): Promise<Uint8Array>;
    export const AES_IV_LENGTH = 16;
    export type AESAlgorithm = "AES-CBC" | "AES-GCM";
    export interface AESCompositeKey {
        key: AESKey;
        subKeys: AESKey[];
    }
    export interface AESEncryptOptions {
        iv?: Uint8Array;
        iv_and_e?: boolean;
        tagLength?: 4 | 8 | 12 | 13 | 14 | 15 | 16;
    }
    export interface AESEncryptionResult {
        cipherText: Uint8Array;
        algo: AESAlgorithm;
        iv?: Uint8Array;
        tag?: Uint8Array;
    }
    export interface AESUnwrapOptions {
        algo?: AESAlgorithm;
        exportable?: boolean;
        iv?: Uint8Array;
        tag?: Uint8Array;
    }
    export function genAESKey(len: 16 | 32, algo: AESAlgorithm): Promise<AESKey>;
    export function genCompositeAESKey(n: number, algo: AESAlgorithm, size?: 16 | 32): Promise<AESCompositeKey>;
    export function importAESKey(key: Uint8Array, algo: AESAlgorithm): Promise<AESKey>;
    export class AESKey {
        readonly key: CryptoKey;
        readonly algo: AESAlgorithm;
        encrypt(data: Uint8Array, opts?: AESEncryptOptions): Promise<AESEncryptionResult>;
        decrypt(data: Uint8Array, iv?: Uint8Array, tag?: Uint8Array): Promise<Uint8Array>;
        wrapAESKey(key: AESKey, opts?: AESEncryptOptions): Promise<AESEncryptionResult>;
        unwrapAESKey(wrapped: Uint8Array, opts?: AESUnwrapOptions): Promise<AESKey>;
        export(): Promise<Uint8Array>;
        constructor(key: CryptoKey);
    }
    export type Curve = "P-256" | "P-384" | "P-521";
    export interface ECDHKeyPair {
        public: ECDHPublic;
        private: ECDHPrivate;
    }
    export function genECDHPair(curve: Curve, exportable?: boolean): Promise<ECDHKeyPair>;
    export function importECDHPublic(data: Uint8Array, format: "raw" | "spki", curve: Curve, exportable?: boolean): Promise<ECDHPublic>;
    export class ECDHPublic {
        readonly key: CryptoKey;
        readonly curve: Curve;
        export(format: "raw" | "spki"): Promise<Uint8Array>;
        constructor(key: CryptoKey, curve: Curve);
    }
    export class ECDHPrivate {
        private readonly key;
        readonly curve: Curve;
        deriveBytes(pub: ECDHPublic, bytes?: number): Promise<Uint8Array>;
        constructor(key: CryptoKey, curve: Curve);
    }
    export interface Signature {
        signature: string;
        saltLength: number;
    }
    export interface ChallengeSignature {
        signature: string;
        serverToken: string;
        clientToken: string;
        saltLen: number;
        challID?: any;
        mfaTokens?: any[];
    }
    export interface RSAKeyPair {
        email?: string;
        public: RSAPublic;
        private: RSAPrivate;
    }
    export interface ExternalRSAPublic {
        modulus: string;
        publicExponent: string;
    }
    export interface ExternalRSAPrivate {
        encrypted: string;
        encoding: "pkcs8";
        kdf: "PBKDF2:SHA-256";
        rounds: number;
        salt?: string;
        encAlgo: "AES-CBC";
        encSize: 32;
        iv?: string;
    }
    export interface ExternalRSAKeyPair {
        email?: string;
        public: ExternalRSAPublic;
        private: ExternalRSAPrivate;
    }
    export interface OldExternalRSAKeyPair {
        email: string;
        key: {
            publicKey: ExternalRSAPublic;
            privateKey: {
                key: OldWrappedRSAPrivate;
                padding: boolean;
                iterations: number;
                salt?: string;
                iv?: string;
            };
        };
    }
    export type OldWrappedRSAPrivate = string;
    export function convertOldKeyPair(old: OldExternalRSAKeyPair, pwd: Uint8Array): Promise<ExternalRSAKeyPair>;
    export function genRSAKeyPair(modLen?: 1024 | 2048 | 4096, pubExp?: Uint8Array): Promise<RSAKeyPair>;
    export function genRSAKeyPairAndExport(pwd: Uint8Array, modLen?: 1024 | 2048 | 4096, pubExp?: Uint8Array): Promise<ExternalRSAKeyPair>;
    export function importRSAKeyPair(ext: ExternalRSAKeyPair, pwd: Uint8Array): Promise<RSAKeyPair>;
    export class RSAPublic {
        readonly pss: CryptoKey;
        readonly oaep: CryptoKey;
        verify(data: Uint8Array, sig: Signature): Promise<boolean>;
        encrypt(clearText: Uint8Array): Promise<Uint8Array>;
        wrapAESKey(key: AESKey): Promise<Uint8Array>;
        export(): Promise<ExternalRSAPublic>;
        constructor(pss: CryptoKey, oaep: CryptoKey);
    }
    export class RSAPrivate {
        private pss;
        private oaep;
        sign(data: Uint8Array, saltLen?: number): Promise<Signature>;
        signChallenge(challenge: string, saltLen?: number): Promise<ChallengeSignature>;
        decrypt(cipherText: Uint8Array): Promise<Uint8Array>;
        unwrapAESKey(wrapped: Uint8Array, algo: "AES-CBC" | "AES-GCM", exportable?: boolean): Promise<AESKey>;
        export(password: Uint8Array, rounds?: number): Promise<ExternalRSAPrivate>;
        extractPublic(): Promise<RSAPublic>;
        constructor(pss: CryptoKey, oaep: CryptoKey);
    }
    export function importRSAPublic(ext: ExternalRSAPublic): Promise<RSAPublic>;
    export function importRSAPrivate(ext: ExternalRSAPrivate, pwd: Uint8Array): Promise<RSAPrivate>;
}