"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function randomBytes(n) {
    if (n < 0)
        throw new Error("Cannot generate negative number of random bytes");
    return new Uint8Array(crypto.getRandomValues(new Uint8Array(n)).buffer);
}
exports.randomBytes = randomBytes;
function randomString(n) {
    return bytesToBase64(randomBytes(n), true);
}
exports.randomString = randomString;
function bytesToHex(binary) {
    return Array.prototype.map.call(binary, (x) => ('00' + x.toString(16)).slice(-2)).join('');
}
exports.bytesToHex = bytesToHex;
function hexToBytes(hex) {
    let binary = new Uint8Array(hex.length / 2);
    for (var i = 0, len = hex.length; i < len; i += 2) {
        binary[i / 2] = parseInt(hex.substr(i, 2), 16);
    }
    return binary;
}
exports.hexToBytes = hexToBytes;
function bytesToBase64(binary, urlSafe) {
    let base64 = btoa(String.fromCharCode(...binary));
    if (urlSafe)
        base64 = base64.replace(/\+/g, '-').replace(/\//g, '_').replace(/=+$/, '');
    return base64;
}
exports.bytesToBase64 = bytesToBase64;
function base64ToBytes(base64) {
    base64 = base64.replace(/\-/g, '+').replace(/_/g, '/').replace(/=+$/, '');
    base64 += '=='.substring(0, (3 * base64.length) % 4);
    let utf = atob(base64);
    let buf = new Uint8Array(utf.length);
    for (let i = 0; i < buf.length; i++)
        buf[i] = utf.charCodeAt(i);
    return buf;
}
exports.base64ToBytes = base64ToBytes;
function equalBuffers(buf1, buf2) {
    if (buf1.length != buf2.length)
        return false;
    let diff = 0;
    for (let i = 0; i < buf1.length; i++)
        diff = diff | (buf1[i] ^ buf2[i]);
    return diff == 0;
}
exports.equalBuffers = equalBuffers;
function sha256(data) {
    return new Promise((resolve, reject) => {
        crypto.subtle.digest({ name: "SHA-256" }, data.buffer).then(hashed => resolve(new Uint8Array(hashed)), () => reject("Unspecified hash error occurred."));
    });
}
exports.sha256 = sha256;
//# sourceMappingURL=misc.js.map