import { AESKey } from "./aes";
export interface Signature {
    signature: string;
    saltLength: number;
}
export interface ChallengeSignature {
    signature: string;
    serverToken: string;
    clientToken: string;
    saltLen: number;
    challID?: any;
    mfaTokens?: any[];
}
export interface RSAKeyPair {
    email?: string;
    public: RSAPublic;
    private: RSAPrivate;
}
export interface ExternalRSAPublic {
    modulus: string;
    publicExponent: string;
}
export interface ExternalRSAPrivate {
    encrypted: string;
    encoding: "pkcs8";
    kdf: "PBKDF2:SHA-256";
    rounds: number;
    salt?: string;
    encAlgo: "AES-CBC";
    encSize: 32;
    iv?: string;
}
export interface ExternalRSAKeyPair {
    email?: string;
    public: ExternalRSAPublic;
    private: ExternalRSAPrivate;
}
export interface OldExternalRSAKeyPair {
    email: string;
    key: {
        publicKey: ExternalRSAPublic;
        privateKey: {
            key: OldWrappedRSAPrivate;
            padding: boolean;
            iterations: number;
            salt?: string;
            iv?: string;
        };
    };
}
export declare type OldWrappedRSAPrivate = string;
export declare function convertOldKeyPair(old: OldExternalRSAKeyPair, pwd: Uint8Array): Promise<ExternalRSAKeyPair>;
export declare function genRSAKeyPair(modLen?: 1024 | 2048 | 4096, pubExp?: Uint8Array): Promise<RSAKeyPair>;
export declare function genRSAKeyPairAndExport(pwd: Uint8Array, modLen?: 1024 | 2048 | 4096, pubExp?: Uint8Array): Promise<ExternalRSAKeyPair>;
export declare function importRSAKeyPair(ext: ExternalRSAKeyPair, pwd: Uint8Array): Promise<RSAKeyPair>;
export declare class RSAPublic {
    readonly pss: CryptoKey;
    readonly oaep: CryptoKey;
    verify(data: Uint8Array, sig: Signature): Promise<boolean>;
    encrypt(clearText: Uint8Array): Promise<Uint8Array>;
    wrapAESKey(key: AESKey): Promise<Uint8Array>;
    export(): Promise<ExternalRSAPublic>;
    constructor(pss: CryptoKey, oaep: CryptoKey);
}
export declare class RSAPrivate {
    private pss;
    private oaep;
    sign(data: Uint8Array, saltLen?: number): Promise<Signature>;
    signChallenge(challenge: string, saltLen?: number): Promise<ChallengeSignature>;
    decrypt(cipherText: Uint8Array): Promise<Uint8Array>;
    unwrapAESKey(wrapped: Uint8Array, algo: "AES-CBC" | "AES-GCM", exportable?: boolean): Promise<AESKey>;
    export(password: Uint8Array, rounds?: number): Promise<ExternalRSAPrivate>;
    extractPublic(): Promise<RSAPublic>;
    constructor(pss: CryptoKey, oaep: CryptoKey);
}
export declare function importRSAPublic(ext: ExternalRSAPublic): Promise<RSAPublic>;
export declare function importRSAPrivate(ext: ExternalRSAPrivate, pwd: Uint8Array): Promise<RSAPrivate>;
