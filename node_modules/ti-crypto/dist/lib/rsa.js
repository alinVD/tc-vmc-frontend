"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const misc_1 = require("./misc");
const aes_1 = require("./aes");
const _der_1 = require("./_der");
function convertOldKeyPair(old, pwd) {
    const version = new Uint8Array([0x02, 0x01, 0x00]);
    const rsaAlgo = new Uint8Array([
        0x30, 0x0D, 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86,
        0xF7, 0x0D, 0x01, 0x01, 0x01, 0x05, 0x00
    ]);
    return new Promise((resolve, reject) => {
        let oldWrapped = misc_1.base64ToBytes(old.key.privateKey.key);
        let salt = misc_1.base64ToBytes(old.key.privateKey.salt);
        let rounds = old.key.privateKey.iterations;
        let iv = misc_1.base64ToBytes(old.key.privateKey.iv);
        crypto.subtle.importKey("raw", pwd.buffer, {
            name: "PBKDF2"
        }, false, ["deriveKey"]).then(derivationKey => {
            pwd.fill(0);
            crypto.subtle.deriveKey({
                name: "PBKDF2",
                salt: salt.buffer,
                iterations: rounds,
                hash: { name: "SHA-256" }
            }, derivationKey, {
                name: "AES-CBC",
                length: 256,
            }, false, ["encrypt", "decrypt"]).then(aesKey => {
                crypto.subtle.decrypt({
                    name: "AES-CBC",
                    iv: iv.buffer
                }, aesKey, oldWrapped.buffer).then(oldUnwrapped => {
                    let decoder = new TextDecoder("utf-8");
                    let keyJson = JSON.parse(decoder.decode(new Uint8Array(oldUnwrapped)));
                    let keyInts = keyJson.map(elem => _der_1.encodeToDER(_der_1.INTEGER, _der_1.unsigned(misc_1.base64ToBytes(elem))));
                    keyInts.unshift(new Uint8Array([0x02, 0x01, 0x00]));
                    let privateKey = _der_1.encodeToDER(_der_1.OCT_STR, _der_1.encodeToDER(_der_1.SEQUENCE, _der_1.concat(...keyInts)));
                    let pkcs8Key = _der_1.encodeToDER(_der_1.SEQUENCE, _der_1.concat(version, rsaAlgo, privateKey));
                    iv = misc_1.randomBytes(16);
                    crypto.subtle.encrypt({
                        name: "AES-CBC",
                        iv: iv.buffer
                    }, aesKey, pkcs8Key.buffer).then(wrapped => resolve({
                        email: old.email,
                        public: old.key.publicKey,
                        private: {
                            encrypted: misc_1.bytesToBase64(new Uint8Array(wrapped)),
                            encoding: "pkcs8",
                            kdf: "PBKDF2:SHA-256",
                            rounds: rounds,
                            salt: misc_1.bytesToBase64(salt),
                            encAlgo: "AES-CBC",
                            encSize: 32,
                            iv: misc_1.bytesToBase64(iv)
                        }
                    }), err => reject(`CryptoSubtle failed to rewrap key (${err}).`));
                }, err => reject(`CryptoSubtle failed to unwrap key (${err}).`));
            }, err => reject(`CryptoSubtle failed to derive unwrapping/re-wrapping key (${err}).`));
        }, err => reject(`CryptoSubtle failed to create derivation key from password (${err}).`));
    }).catch(err => { throw new Error(`RSA convert deprecated key pair: ${err}`); });
}
exports.convertOldKeyPair = convertOldKeyPair;
function genRSAKeyPair(modLen, pubExp) {
    return new Promise((resolve, reject) => {
        crypto.subtle.generateKey({
            name: "RSA-PSS",
            modulusLength: modLen || 2048,
            publicExponent: pubExp || new Uint8Array([0x01, 0x00, 0x01]),
            hash: { name: "SHA-256" }
        }, true, ["sign", "verify"]).then(pssPair => {
            Promise.all([
                crypto.subtle.exportKey("spki", pssPair.publicKey),
                crypto.subtle.exportKey("pkcs8", pssPair.privateKey)
            ]).then(([rawPub, rawPriv]) => {
                const algo = {
                    name: "RSA-OAEP",
                    hash: { name: "SHA-256" }
                };
                Promise.all([
                    crypto.subtle.importKey("spki", rawPub, algo, true, ["encrypt", "wrapKey"]),
                    crypto.subtle.importKey("pkcs8", rawPriv, algo, true, ["decrypt", "unwrapKey"])
                ]).then(([oaepPub, oaepPriv]) => {
                    new Uint8Array(rawPriv).fill(0);
                    resolve({
                        public: new RSAPublic(pssPair.publicKey, oaepPub),
                        private: new RSAPrivate(pssPair.privateKey, oaepPriv)
                    });
                }, err => reject(`RSA gen key: CryptoSubtle failed to re-import keys as OAEP (${err}).`));
            }, err => reject(`RSA gen key: CryptoSubtle failed to export raw keys (${err}).`));
        }, err => reject(`RSA gen key: CryptoSubtle error (${err}).`));
    });
}
exports.genRSAKeyPair = genRSAKeyPair;
;
function genRSAKeyPairAndExport(pwd, modLen, pubExp) {
    return new Promise((resolve, reject) => {
        crypto.subtle.generateKey({
            name: "RSA-PSS",
            modulusLength: modLen || 2048,
            publicExponent: pubExp || new Uint8Array([0x01, 0x00, 0x01]),
            hash: { name: "SHA-256" }
        }, true, ["sign", "verify"]).then(keyPair => {
            exportRSAPrivate(keyPair.privateKey, pwd).then(extPriv => {
                exportRSAPublic(keyPair.publicKey).then(extPub => resolve({
                    public: extPub,
                    private: extPriv
                }), err => reject(`RSA gen key: ${err}`));
            }, err => reject(`RSA gen key: ${err}`));
        }, err => reject(`RSA gen key: CryptoSubtle error (${err}).`));
    });
}
exports.genRSAKeyPairAndExport = genRSAKeyPairAndExport;
;
function importRSAKeyPair(ext, pwd) {
    return Promise.all([
        importRSAPublic(ext.public),
        importRSAPrivate(ext.private, pwd)
    ]).then(([pubkey, privKey]) => {
        return {
            email: ext.email,
            public: pubkey,
            private: privKey
        };
    });
}
exports.importRSAKeyPair = importRSAKeyPair;
class RSAPublic {
    verify(data, sig) {
        return new Promise((resolve, reject) => {
            crypto.subtle.verify({
                name: "RSA-PSS",
                saltLength: sig.saltLength
            }, this.pss, misc_1.base64ToBytes(sig.signature).buffer, data.buffer).then(resolve, err => reject(`RSA verify: CryptoSubtle error (${err}).`));
        });
    }
    encrypt(clearText) {
        return new Promise((resolve, reject) => {
            crypto.subtle.encrypt({
                name: "RSA-OAEP",
            }, this.oaep, clearText.buffer).then(encrypted => resolve(new Uint8Array(encrypted)), err => reject(new Error(`RSA encrypt: CryptoSubtle error (${err}).`)));
        });
    }
    wrapAESKey(key) {
        return new Promise((resolve, reject) => {
            if (!key.key.extractable)
                throw new Error("AES key cannot be wrapped because it is not exportable.");
            crypto.subtle.wrapKey("raw", key.key, this.oaep, {
                name: "RSA-OAEP",
                hash: { name: "SHA-256" }
            }).then(wrapped => resolve(new Uint8Array(wrapped)), err => reject(`RSA wrap key: CryptoSubtle error (${err})`));
        });
    }
    export() {
        return exportRSAPublic(this.pss);
    }
    constructor(pss, oaep) {
        this.pss = pss;
        this.oaep = oaep;
    }
}
exports.RSAPublic = RSAPublic;
class RSAPrivate {
    sign(data, saltLen) {
        return new Promise((resolve, reject) => {
            saltLen = saltLen ? saltLen : 32;
            crypto.subtle.sign({
                name: "RSA-PSS",
                saltLength: saltLen
            }, this.pss, data.buffer).then(sig => resolve({
                signature: misc_1.bytesToBase64(new Uint8Array(sig)),
                saltLength: saltLen
            }), err => reject(new Error(`RSA sign: CryptoSubtle error (${err}).`)));
        });
    }
    signChallenge(challenge, saltLen) {
        return new Promise((resolve, reject) => {
            let serverToken = misc_1.base64ToBytes(challenge);
            let clientToken = misc_1.randomBytes(32);
            let dataToSign = new Uint8Array(serverToken.length + clientToken.length);
            dataToSign.set(serverToken, 0);
            dataToSign.set(clientToken, serverToken.length);
            this.sign(dataToSign, saltLen).then(sig => resolve({
                signature: sig.signature,
                serverToken: challenge,
                clientToken: misc_1.bytesToBase64(clientToken),
                saltLen: sig.saltLength
            }), reject);
        });
    }
    decrypt(cipherText) {
        return new Promise((resolve, reject) => {
            crypto.subtle.decrypt({
                name: "RSA-OAEP"
            }, this.oaep, cipherText.buffer).then(clearText => resolve(new Uint8Array(clearText)), err => reject(`RSA decrypt: CryptoSubtle error (${err}).`));
        });
    }
    unwrapAESKey(wrapped, algo, exportable) {
        return new Promise((resolve, reject) => {
            crypto.subtle.unwrapKey("raw", wrapped.buffer, this.oaep, {
                name: "RSA-OAEP",
                hash: { name: "SHA-256" }
            }, {
                name: algo
            }, exportable ? true : false, ["encrypt", "decrypt", "wrapKey", "unwrapKey"]).then(unwrapped => resolve(new aes_1.AESKey(unwrapped)), err => reject(`RSA unwrap key: CryptoSubtle error (${err}).`));
        });
    }
    export(password, rounds) {
        return exportRSAPrivate(this.pss, password, rounds);
    }
    extractPublic() {
        return new Promise((resolve, reject) => {
            crypto.subtle.exportKey("pkcs8", this.pss).then(pkcs8 => {
                let keySeq = _der_1.decodeDER(_der_1.decodeDER(_der_1.decodeDER(_der_1.decodeDER(_der_1.decodeDER(new Uint8Array(pkcs8)).content).remaining).remaining).content).content;
                let rsaVersion = _der_1.decodeDER(keySeq);
                let nBlock = _der_1.decodeDER(rsaVersion.remaining);
                let eBlock = _der_1.decodeDER(nBlock.remaining);
                let spki = makeSPKI(nBlock.content, eBlock.content);
                Promise.all([
                    crypto.subtle.importKey("spki", spki.buffer, {
                        name: "RSA-PSS",
                        hash: { name: "SHA-256" }
                    }, true, ["verify"]),
                    crypto.subtle.importKey("spki", spki.buffer, {
                        name: "RSA-OAEP",
                        hash: { name: "SHA-256" }
                    }, true, ["encrypt", "wrapKey"])
                ]).then(([pss, oaep]) => {
                    resolve(new RSAPublic(pss, oaep));
                    new Uint8Array(pkcs8).fill(0);
                }, err => {
                    reject(`CryptoSubtle failed to import SPKI public key (${err}).`);
                    new Uint8Array(pkcs8).fill(0);
                });
            }, err => reject(`CryptoSubtle failed to export private to PKCS8 (${err}).`));
        }).catch(err => { throw new Error(`RSA extract public: ${err}`); });
    }
    constructor(pss, oaep) {
        this.pss = pss;
        this.oaep = oaep;
    }
}
exports.RSAPrivate = RSAPrivate;
function importRSAPublic(ext) {
    return new Promise((resolve, reject) => {
        let spki = externalRSAPublicToSPKI(ext);
        Promise.all([
            crypto.subtle.importKey("spki", spki.buffer, {
                name: "RSA-PSS",
                hash: { name: "SHA-256" }
            }, true, ["verify"]),
            crypto.subtle.importKey("spki", spki.buffer, {
                name: "RSA-OAEP",
                hash: { name: "SHA-256" }
            }, true, ["encrypt", "wrapKey"])
        ]).then(([pss, oaep]) => resolve(new RSAPublic(pss, oaep)), err => reject(new Error(`RSA import public: CryptoSubtle error (${err}).`)));
    });
}
exports.importRSAPublic = importRSAPublic;
function importRSAPrivate(ext, pwd) {
    return new Promise((resolve, reject) => {
        crypto.subtle.importKey("raw", pwd.buffer, {
            name: "PBKDF2"
        }, false, ["deriveKey"]).then(derivationKey => {
            pwd.fill(0);
            let kdfAndHash = ext.kdf.split(":");
            crypto.subtle.deriveKey({
                name: kdfAndHash[0],
                salt: misc_1.base64ToBytes(ext.salt).buffer,
                iterations: ext.rounds,
                hash: { name: kdfAndHash[1] }
            }, derivationKey, {
                name: ext.encAlgo,
                length: ext.encSize * 8,
            }, false, ["unwrapKey"]).then(decryptionKey => {
                let encryptedPrivate = misc_1.base64ToBytes(ext.encrypted);
                let iv = misc_1.base64ToBytes(ext.iv).buffer;
                Promise.all([
                    crypto.subtle.unwrapKey(ext.encoding, encryptedPrivate, decryptionKey, {
                        name: ext.encAlgo,
                        iv: iv
                    }, {
                        name: "RSA-PSS",
                        hash: { name: "SHA-256" }
                    }, false, ["sign"]),
                    crypto.subtle.unwrapKey(ext.encoding, encryptedPrivate, decryptionKey, {
                        name: ext.encAlgo,
                        iv: iv
                    }, {
                        name: "RSA-OAEP",
                        hash: { name: "SHA-256" }
                    }, false, ["decrypt", "unwrapKey"])
                ]).then(([pss, oaep]) => {
                    resolve(new RSAPrivate(pss, oaep));
                }, err => reject(`CryptoSubtle failed to unwrap key (${err}).`));
            }, err => reject(`CryptoSubtle failed to derive unwrapping key (${err}).`));
        }, err => reject(`CryptoSubtle failed to create derivation key from password (${err}).`));
    }).catch(err => { throw new Error(`RSA import private: ${err}`); });
}
exports.importRSAPrivate = importRSAPrivate;
function exportRSAPublic(key) {
    return new Promise((resolve, reject) => {
        crypto.subtle.exportKey("spki", key).then(spki => resolve(spkiToExternalRSAPublic(new Uint8Array(spki))), err => reject(`RSA export public: CryptoSubtle error (${err}).`));
    });
}
function exportRSAPrivate(key, pwd, rounds) {
    return new Promise((resolve, reject) => {
        let salt = misc_1.randomBytes(16);
        let iv = misc_1.randomBytes(16);
        rounds = rounds || 20000;
        crypto.subtle.importKey("raw", pwd.buffer, { name: "PBKDF2" }, false, ["deriveKey"]).then(derivationKey => {
            pwd.fill(0);
            crypto.subtle.deriveKey({
                name: "PBKDF2",
                salt: salt.buffer,
                iterations: rounds,
                hash: { name: "SHA-256" }
            }, derivationKey, {
                name: "AES-CBC",
                length: 256,
            }, false, ["wrapKey"]).then(wrappingKey => {
                crypto.subtle.wrapKey("pkcs8", key, wrappingKey, {
                    name: "AES-CBC",
                    iv: iv.buffer
                }).then(wrappedPrivate => {
                    resolve({
                        encrypted: misc_1.bytesToBase64(new Uint8Array(wrappedPrivate)),
                        encoding: "pkcs8",
                        kdf: "PBKDF2:SHA-256",
                        rounds: rounds,
                        salt: misc_1.bytesToBase64(salt),
                        encAlgo: "AES-CBC",
                        encSize: 32,
                        iv: misc_1.bytesToBase64(iv)
                    });
                }, err => reject(`CryptoSubtle failed to wrap key (${err}).`));
            }, err => reject(`CryptoSubtle failed to derive wrapping key (${err}).`));
        }, err => reject(`CryptoSubtle failed to create derivation key from password (${err}).`));
    }).catch(err => { throw new Error(`RSA export private: ${err}`); });
}
function spkiToExternalRSAPublic(spki) {
    let rootSeq = _der_1.decodeDER(spki);
    let keyAlgo = _der_1.decodeDER(rootSeq.content);
    let bitStr = _der_1.decodeDER(keyAlgo.remaining);
    let pubKey = _der_1.decodeDER(bitStr.content.slice(1));
    let modulus = _der_1.decodeDER(pubKey.content);
    let publicExponent = _der_1.decodeDER(modulus.remaining);
    return {
        modulus: misc_1.bytesToBase64(modulus.content),
        publicExponent: misc_1.bytesToBase64(publicExponent.content)
    };
}
function externalRSAPublicToSPKI(ext) {
    return makeSPKI(misc_1.base64ToBytes(ext.modulus), misc_1.base64ToBytes(ext.publicExponent));
}
function makeSPKI(n, e) {
    n = _der_1.encodeToDER(_der_1.INTEGER, _der_1.unsigned(n));
    e = _der_1.encodeToDER(_der_1.INTEGER, _der_1.unsigned(e));
    let pubKey = _der_1.encodeToDER(_der_1.SEQUENCE, _der_1.concat(n, e));
    let preEOC = new Uint8Array(1 + pubKey.length);
    preEOC[0] = _der_1.EOC;
    preEOC.set(pubKey, 1);
    const rsaAlgoID = new Uint8Array([
        0x30, 0x0D, 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86,
        0xF7, 0x0D, 0x01, 0x01, 0x01, 0x05, 0x00
    ]);
    let bitStr = _der_1.encodeToDER(_der_1.BIT_STR, preEOC);
    return _der_1.encodeToDER(_der_1.SEQUENCE, _der_1.concat(rsaAlgoID, bitStr));
}
//# sourceMappingURL=rsa.js.map