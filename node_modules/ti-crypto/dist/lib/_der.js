"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.EOC = 0x00;
exports.INTEGER = 0x02;
exports.BIT_STR = 0x03;
exports.OCT_STR = 0x04;
exports.SEQUENCE = 0x30;
function encodeToDER(type, buf) {
    let primitive;
    let lenOctets = 1;
    if (buf.length >= 0x80) {
        let nLenBytes = base256Len(buf.length);
        lenOctets += nLenBytes;
        primitive = new Uint8Array(1 + 1 + nLenBytes + buf.length);
        primitive[1] = 0x80 + nLenBytes;
        for (let n = buf.length, i = 1 + nLenBytes; n > 0; n = Math.floor(n / 256), i--)
            primitive[i] = n % 256;
    }
    else {
        primitive = new Uint8Array(1 + 1 + buf.length);
        primitive[1] = buf.length;
    }
    primitive[0] = type;
    primitive.set(buf, 1 + lenOctets);
    return primitive;
}
exports.encodeToDER = encodeToDER;
function base256Len(val) {
    return Math.ceil(Math.log2(val + 1) / 8);
}
exports.base256Len = base256Len;
function unsigned(int) {
    if (int.length == 0)
        throw new Error("Attempted to convert an empty Uint8Array to an unsigned buffer.");
    let firstNonzero = 0;
    while (int[firstNonzero] == 0)
        firstNonzero++;
    if (firstNonzero != 0)
        return int[firstNonzero] >= 0x80 ? int.slice(firstNonzero - 1) : int.slice(firstNonzero);
    else
        return int[firstNonzero] >= 0x80 ? new Uint8Array([0, ...int]) : int;
}
exports.unsigned = unsigned;
function concat(...bufs) {
    let tLen = 0;
    for (let i = 0; i < bufs.length; i++)
        tLen += bufs[i].length;
    let concatenated = new Uint8Array(tLen);
    let offset = 0;
    for (let i = 0; i < bufs.length; i++) {
        concatenated.set(bufs[i], offset);
        offset += bufs[i].length;
    }
    return concatenated;
}
exports.concat = concat;
function decodeDER(buf) {
    if (buf[0] == 0x00) {
        return {
            type: 0x00,
            content: new Uint8Array(0),
            remaining: buf.slice(1)
        };
    }
    let off = 0;
    let len = 0;
    if (buf[1] > 0x80) {
        off = 2 + (buf[1] - 0x80);
        len = decodeBase256Integer(buf.slice(2, off));
    }
    else if (buf[1] > 0 && buf[1] < 0x80) {
        off = 2;
        len = buf[1];
    }
    else {
        throw new Error(`Bad ASN length identifier (${buf[1]}).`);
    }
    return {
        type: buf[0],
        content: buf.slice(off, off + len),
        remaining: buf.slice(off + len)
    };
}
exports.decodeDER = decodeDER;
function decodeBase256Integer(buf, signed) {
    if (buf.length == 0)
        return 0;
    let value = (buf[0] >= 0x80 && signed) ? -Math.pow(256, buf.length) : 0;
    for (let i = buf.length - 1, sig = 1; i >= 0; i--, sig *= 256)
        value += buf[i] * sig;
    return value;
}
exports.decodeBase256Integer = decodeBase256Integer;
//# sourceMappingURL=_der.js.map