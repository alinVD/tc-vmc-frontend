"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const misc_1 = require("./misc");
const _der_1 = require("./_der");
exports.AES_IV_LENGTH = 16;
function genAESKey(len, algo) {
    return new Promise((resolve, reject) => {
        crypto.subtle.generateKey({
            name: algo,
            length: len * 8
        }, true, ["encrypt", "decrypt", "wrapKey", "unwrapKey"]).then(key => resolve(new AESKey(key)), err => reject(`AES gen key: CryptoSubtle error (${err}).`));
    });
}
exports.genAESKey = genAESKey;
function genCompositeAESKey(n, algo, size) {
    return new Promise((resolve, reject) => {
        size = size || 32;
        if (n < 2)
            throw new Error(`Must generate at least 2 sub-keys (given: ${n}).`);
        let keyImports = [];
        let master = new Uint8Array(size);
        for (let i = 0; i < n; i++) {
            let key = misc_1.randomBytes(size);
            for (let k = 0; k < size; k++) {
                master[k] = master[k] ^ key[k];
            }
            keyImports.push(importAESKey(key, algo));
        }
        Promise.all([
            importAESKey(master, algo),
            ...keyImports
        ]).then(aesKeys => {
            resolve({
                key: aesKeys[0],
                subKeys: aesKeys.slice(1)
            });
        }, err => reject(`Composite AES key gen: ${err}`));
    });
}
exports.genCompositeAESKey = genCompositeAESKey;
function importAESKey(key, algo) {
    return new Promise((resolve, reject) => {
        crypto.subtle.importKey("raw", key.buffer, {
            name: algo
        }, true, ["encrypt", "decrypt", "wrapKey", "unwrapKey"]).then(cryptoKey => {
            key.fill(0);
            resolve(new AESKey(cryptoKey));
        }, err => reject(`AES import key: CryptoSubtle error (${err}).`));
    });
}
exports.importAESKey = importAESKey;
class AESKey {
    encrypt(data, opts) {
        return new Promise((resolve, reject) => {
            opts = opts || {};
            opts.iv = opts.iv || misc_1.randomBytes(exports.AES_IV_LENGTH);
            if (opts.iv.length != exports.AES_IV_LENGTH)
                throw new Error(`AES encrypt: bad IV length (expected ${exports.AES_IV_LENGTH}, got ${opts.iv.length}).`);
            crypto.subtle.encrypt({
                name: this.algo,
                iv: opts.iv
            }, this.key, data.buffer).then(encrypted => {
                data.fill(0);
                let cipherText = new Uint8Array(encrypted);
                let result = {
                    cipherText: misc_1.bytesToBase64(opts.iv_and_e ? _der_1.concat(opts.iv, cipherText) : cipherText),
                    algo: this.algo
                };
                if (!opts.iv_and_e)
                    result.iv = misc_1.bytesToBase64(opts.iv);
                resolve(result);
            }, err => reject(`AES encrypt: CryptoSubtle error (${err}).`));
        });
    }
    decrypt(data, algo, iv) {
        return new Promise((resolve, reject) => {
            let cipherText;
            if (!iv) {
                iv = data.slice(0, exports.AES_IV_LENGTH);
                data = data.slice(exports.AES_IV_LENGTH);
            }
            crypto.subtle.decrypt({
                name: algo,
                iv: iv.buffer
            }, this.key, data.buffer).then(clearText => resolve(new Uint8Array(clearText)), err => reject(`AES decrypt: CryptoSubtle error (${err}).`));
        });
    }
    wrapAESKey(key, opts) {
        return new Promise((resolve, reject) => {
            opts = opts || {};
            opts.iv = opts.iv || misc_1.randomBytes(exports.AES_IV_LENGTH);
            crypto.subtle.wrapKey("raw", key.key, this.key, {
                name: "AES-CBC",
                iv: opts.iv.buffer
            }).then(wrappedKey => {
                let cipherText = new Uint8Array(wrappedKey);
                let result = {
                    cipherText: misc_1.bytesToBase64(opts.iv_and_e ? _der_1.concat(opts.iv, cipherText) : cipherText),
                    algo: this.algo
                };
                if (!opts.iv_and_e)
                    result.iv = misc_1.bytesToBase64(opts.iv);
                resolve(result);
                cipherText.fill(0);
            }, err => reject(`AES wrap key: CryptoSubtle error (${err}).`));
        });
    }
    unwrapAESKey(wrapped, opts) {
        return new Promise((resolve, reject) => {
            opts = opts || {};
            let cipherText;
            if (opts.iv) {
                cipherText = wrapped;
            }
            else {
                opts.iv = wrapped.slice(0, exports.AES_IV_LENGTH);
                cipherText = wrapped.slice(exports.AES_IV_LENGTH);
            }
            crypto.subtle.unwrapKey("raw", cipherText.buffer, this.key, {
                name: this.algo,
                iv: opts.iv.buffer
            }, {
                name: opts.algo || "AES-CBC"
            }, opts.exportable ? true : false, [
                "encrypt",
                "decrypt",
                "wrapKey",
                "unwrapKey"
            ]).then(unwrapped => resolve(new AESKey(unwrapped)), err => reject(`AES unwrap key: CryptoSubtle error (${err}).`));
        });
    }
    export() {
        return new Promise((resolve, reject) => {
            crypto.subtle.exportKey("raw", this.key).then(raw => resolve(new Uint8Array(raw)), err => reject(`AES export key: CryptoSubtle error (${err}).`));
        });
    }
    constructor(key) {
        this.key = key;
        this.algo = key.algorithm.name;
    }
}
exports.AESKey = AESKey;
//# sourceMappingURL=aes.js.map