export declare const AES_IV_LENGTH = 16;
export declare type AESAlgorithm = "AES-CBC" | "AES-GCM";
export interface AESCompositeKey {
    key: AESKey;
    subKeys: AESKey[];
}
export interface AESEncryptOptions {
    iv?: Uint8Array;
    iv_and_e?: boolean;
    tagLength?: 4 | 8 | 12 | 13 | 14 | 15 | 16;
}
export interface AESEncryptionResult {
    cipherText: Uint8Array;
    algo: AESAlgorithm;
    iv?: Uint8Array;
    tag?: Uint8Array;
}
export interface AESUnwrapOptions {
    algo?: AESAlgorithm;
    exportable?: boolean;
    iv?: Uint8Array;
    tag?: Uint8Array;
}
export declare function genAESKey(len: 16 | 32, algo: AESAlgorithm): Promise<AESKey>;
export declare function genCompositeAESKey(n: number, algo: AESAlgorithm, size?: 16 | 32): Promise<AESCompositeKey>;
export declare function importAESKey(key: Uint8Array, algo: AESAlgorithm): Promise<AESKey>;
export declare class AESKey {
    readonly key: CryptoKey;
    readonly algo: AESAlgorithm;
    encrypt(data: Uint8Array, opts?: AESEncryptOptions): Promise<AESEncryptionResult>;
    decrypt(data: Uint8Array, iv?: Uint8Array, tag?: Uint8Array): Promise<Uint8Array>;
    wrapAESKey(key: AESKey, opts?: AESEncryptOptions): Promise<AESEncryptionResult>;
    unwrapAESKey(wrapped: Uint8Array, opts?: AESUnwrapOptions): Promise<AESKey>;
    export(): Promise<Uint8Array>;
    constructor(key: CryptoKey);
}
