/**
 * Miscellaneous crypto functions.
 * 
 * @author Sam Claus
 * @version 10/4/17
 * @copyright Tera Insights, LLC.
 */

/**
 * Generates random bytes.
 * @param n Number of bytes to generate.
 * @returns A Uint8Array of n random bytes.
 */
export function randomBytes(n: number): Uint8Array {
    if (n < 0)
        throw new Error("Cannot generate negative number of random bytes");
    return new Uint8Array(crypto.getRandomValues(new Uint8Array(n)).buffer);
}

/**
 * Generates random bytes and encodes them to a URL-safe Base64 string.
 * @param n Number of bytes to generate.
 * @returns A Base64-web string.
 */
export function randomString(n: number): string {
    return bytesToBase64(randomBytes(n), true);
}

/**
 * Encodes binary data to hex.
 * @param   binary The binary data to encode.
 * @returns        A hex string.
 */
export function bytesToHex(binary: Uint8Array): string {
    return Array.prototype.map.call(binary, (x: number) =>
        ('00' + x.toString(16)).slice(-2)).join('');
}

/**
 * Decodes a hex string to binary.
 * @param   hex The encoded data.
 * @returns     The decoded data.
 */
export function hexToBytes(hex: string): Uint8Array {
    let binary = new Uint8Array(hex.length / 2);
    for (var i = 0, len = hex.length; i < len; i+=2) {
        binary[i/2] = parseInt(hex.substr(i,2),16);
    }
    return binary;
}

/**
 * Encodes binary data to Base64.
 * @param binary  The binary data to encode.
 * @param urlSafe True if the Base64 must be URL-safe, meaning '+' is replaced
 *                with '-', '/' is replaced with '_', and padding is omitted.
 * @returns       A Base64 string.
 */
export function bytesToBase64(binary: Uint8Array, urlSafe?: boolean): string {
    let base64 = btoa(String.fromCharCode(...binary));
    if (urlSafe)
        base64 = base64.replace(/\+/g, '-').replace(/\//g, '_').replace(/=+$/, '');
    return base64;
}

/**
 * Decodes a Base64 string to binary.
 * @param base64 The encoded data.
 * @returns The decoded binary.
 */
export function base64ToBytes(base64: string): Uint8Array {
    base64 = base64.replace(/\-/g, '+').replace(/_/g, '/').replace(/=+$/, '');
    base64 += '=='.substring(0, (3 * base64.length) % 4);

    let utf = atob(base64);
    let buf = new Uint8Array(utf.length);

    for (let i = 0; i < buf.length; i++)
        buf[i] = utf.charCodeAt(i);

    return buf;
}

/**
 * Compares two buffers to see if they are equal. Comparison should occur in
 * constant time.
 * @param buf1 First buffer.
 * @param buf2 Second buffer.
 * @returns Whether or not the buffers are equal.
 */
export function equalBuffers(buf1: Uint8Array, buf2: Uint8Array): boolean {
    if (buf1.length != buf2.length)
        return false;

    let diff = 0;
    for (let i = 0; i < buf1.length; i++)
        diff = diff | (buf1[i] ^ buf2[i]);

    return diff == 0;
}

/**
 * Hashes data using SHA-256.
 * @param data Data to hash.
 * @returns The hashed bytes.
 */
export function sha256(data: Uint8Array): Promise<Uint8Array> {
    return new Promise((resolve, reject) => {
        crypto.subtle.digest({name: "SHA-256"}, data.buffer).then(
            hashed => resolve(new Uint8Array(hashed)),
            () => reject("Unspecified hash error occurred.")
        );
    });
}