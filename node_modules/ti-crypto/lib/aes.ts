// Copyright 2017 Tera Insights, LLC. All rights reserved.

import {randomBytes, sha256} from "./misc";
import {concat} from "./der";

/* The IV length, in bytes, that must be used for AES-CBC. */
export const AES_IV_LENGTH = 16;

export type AESAlgorithm = "AES-CBC"|"AES-GCM" // Supported AES algorithms.

export interface AESCompositeKey {
    key:     AESKey;   // Master key, produced by XORing subKeys; not exportable.
    subKeys: AESKey[]; // Individually generated keys; all of them are exportable.
}

export interface AESEncryptOptions {
    iv?:        Uint8Array;         // IV to use for encryption, must be AES_IV_LENGTH bytes long; generated if not provided.
    iv_and_e?:  boolean;            // True if the IV should be prepended to the encrypted data, false if it should be attached
                                    // to the JSON; default is false.
    tagLength?: 4|8|12|13|14|15|16; // AES-GCM tag length, in bytes; default is 16.
}

export interface AESEncryptionResult {
    cipherText: Uint8Array;   // Encrypted data.
    algo:       AESAlgorithm; // The algorithm used to encrypt the data.
    iv?:        Uint8Array;   // The encryption IV; if null, the IV has been prepended to cipherText.
    tag?:       Uint8Array;   // The encryption tag (AES-GCM only).
}

export interface AESUnwrapOptions {
    algo?:       AESAlgorithm; // The algorithm to use with the unwrapped key; default is AES-CBC.
    exportable?: boolean;      // Whether the unwrapped (usable) CryptoKey should be exportable; default is false;
    iv?:         Uint8Array;   // Encryption IV; if null, it is assumed that the IV is prepended to the wrapped key.
    tag?:        Uint8Array;   // Encryption tag (AES-GCM only).
}

/**
 * Generates a new AES key.
 * @param   len  The length of the key, in bytes.
 * @param   algo The key algorithm to use.
 * @returns      A promise fulfilling with an AES key.
 */
export function genAESKey(len: 16|32, algo: AESAlgorithm): Promise<AESKey> {
    return new Promise((resolve, reject) => {
        crypto.subtle.generateKey({
            name: algo,
            length: len * 8
        }, true, ["encrypt", "decrypt", "wrapKey", "unwrapKey"]).then(
            key => resolve(new AESKey(key)),
            err => reject(`AES gen key: CryptoSubtle error (${err}).`)
        );
    });
}
    
/**
 * Generates a new set of AES keys, and then XORs them together
 * to create a master key. Please note that this method does not
 * exist in CryptoSubtle and is done in the clear.
 * @param   n    The number of sub-keys to generate.
 * @param   algo The algorithm to use for all of the keys.
 * @param   size The size, in bytes, of the AES keys; default is 32.
 * @returns      A set of sub-keys and a master key produced by XORing
 *               the sub-keys. The master key is not exportable/wrappable.
 */
export function genCompositeAESKey(n: number, algo: AESAlgorithm, size?: 16|32): Promise<AESCompositeKey> {
    return new Promise((resolve, reject) => {
        size = size || 32;
    
        if (n < 2)
            throw new Error(`Must generate at least 2 sub-keys (given: ${n}).`);
    
        let keyImports: Promise<AESKey>[] = [];
        let master = new Uint8Array(size);
    
        for (let i = 0; i < n; i++) {
            let key = randomBytes(size);
            for (let k = 0; k < size; k++) {
                master[k] = master[k] ^ key[k];
            }

            keyImports.push(importAESKey(key, algo));
        }

        Promise.all([
            importAESKey(master, algo),
            ...keyImports
        ]).then(aesKeys => {
            resolve({
                key: aesKeys[0],
                subKeys: aesKeys.slice(1)
            });
        }, err => reject(`Composite AES key gen: ${err}`));
    });
}

/**
 * Directly imports a raw AES key.
 * @param   key  The raw key data; wiped upon successful import.
 * @param   algo The algorithm to use for the imported key.
 * @returns      A promise fulfilling with an AES key.
 */
export function importAESKey(key: Uint8Array, algo: AESAlgorithm): Promise<AESKey> {
    return new Promise((resolve, reject) => {
        crypto.subtle.importKey("raw", key.buffer, {
            name: algo
        }, true, ["encrypt", "decrypt", "wrapKey", "unwrapKey"]).then(
            cryptoKey => {
                key.fill(0);
                resolve(new AESKey(cryptoKey));
            },
            err => reject(`AES import key: CryptoSubtle error (${err}).`)
        );
    });
}

/**
 * Wrapper around a CryptoSubtle AES key.
 * 
 * @author Sam Claus
 * @version 9/26/17
 * @copyright Tera Insights, LLC.
 */
export class AESKey {

    /* Opaque CryptoSubtle key reference. */
    public readonly key: CryptoKey;
    public readonly algo: AESAlgorithm;

    /**
     * Safely encrypts data using CryptoSubtle.
     * @param   data The data to encrypt; wiped from memory after encryption.
     * @param   opts Encryption options; defaults are documented
     *               under the AESEncryptOptions definition.
     * @returns      Encrypted data, plus encryption options used.
     */
    public encrypt(data: Uint8Array, opts?: AESEncryptOptions): Promise<AESEncryptionResult> {
        return new Promise((resolve, reject) => {
            opts = opts || {};
            opts.iv = opts.iv || randomBytes(AES_IV_LENGTH);

            if (opts.iv.length != AES_IV_LENGTH)
                throw new Error(`AES encrypt: bad IV length (expected ${AES_IV_LENGTH}, got ${opts.iv.length}).`);

            let encryptOpts: any = {
                name: this.algo,
                iv: opts.iv
            };

            if (this.algo === "AES-GCM")
                encryptOpts.tagLength = opts.tagLength ? opts.tagLength * 8 : 128;

            crypto.subtle.encrypt(encryptOpts, this.key, data.buffer).then(encrypted => {
                data.fill(0);

                let cipherText = new Uint8Array(encrypted);
                let tag: Uint8Array;

                if (this.algo === "AES-GCM") {
                    let tagIndex = cipherText.byteLength - (encryptOpts.tagLength / 8);
                    tag = cipherText.subarray(tagIndex);
                    cipherText = cipherText.subarray(0, tagIndex);
                }

                let result: AESEncryptionResult = {
                    cipherText: opts.iv_and_e ? concat(opts.iv, cipherText) : cipherText,
                    algo: this.algo
                };

                if (!opts.iv_and_e)
                    result.iv = opts.iv;

                if (tag)
                    result.tag = tag;

                resolve(result);
            }, err => reject(`AES encrypt: CryptoSubtle error (${err}).`));
        });
    }

    /**
     * Safely decrypts data using CryptoSubtle.
     * @param   data The encrypted data, with the encryption IV prepended
     *               if opts.iv_and_e is true.
     * @param   iv   The encryption IV. If null, the first AES_IV_LENGTH
     *               bytes of data are assumed to be the IV.
     * @param   tag  The encryption tag (AES-GCM only).
     * @returns      The decrypted data.
     */
    public decrypt(data: Uint8Array, iv?: Uint8Array, tag?: Uint8Array): Promise<Uint8Array> {
        return new Promise<Uint8Array>((resolve, reject) => {
            if (!iv) {
                iv = data.subarray(0, AES_IV_LENGTH);
                data = data.subarray(AES_IV_LENGTH);
            }

            let decryptOpts: any = {
                name: this.algo,
                iv: iv.buffer
            };

            if (tag) {
                data = concat(data, tag);
                decryptOpts.tagLength = tag.byteLength * 8;
            } else if (this.algo === "AES-GCM") {
                throw new Error("no tag provided for AES-GCM decryption");
            }

            crypto.subtle.decrypt(decryptOpts, this.key, data.buffer).then(
                clearText => resolve(new Uint8Array(clearText)),
                err => reject(`AES decrypt: CryptoSubtle error (${err}).`)
            );
        });
    }

    /**
     * Wraps another AES key using this one.
     * @param   key  The AES key to wrap (encrypt).
     * @param   opts Encryption options.
     * @returns      A promise fulfilling with the result of encrypting
     *               the raw key bytes.
     */
    public wrapAESKey(key: AESKey, opts?: AESEncryptOptions): Promise<AESEncryptionResult> {
        return new Promise((resolve, reject) => {
            opts = opts || {};
            opts.iv = opts.iv || randomBytes(AES_IV_LENGTH);

            let encryptOpts: any = {
                name: this.algo,
                iv: opts.iv.buffer
            };

            if (this.algo === "AES-GCM")
                encryptOpts.tagLength = opts.tagLength ? opts.tagLength * 8 : 128;

            crypto.subtle.wrapKey("raw", key.key, this.key, encryptOpts).then(wrappedKey => {
                let cipherText = new Uint8Array(wrappedKey);
                let tag: Uint8Array;

                if (this.algo === "AES-GCM") {
                    let tagIndex = cipherText.byteLength - (encryptOpts.tagLength / 8);
                    tag = cipherText.subarray(tagIndex);
                    cipherText = cipherText.subarray(0, tagIndex);
                }

                let result: AESEncryptionResult = {
                    cipherText: opts.iv_and_e ? concat(opts.iv, cipherText) : cipherText,
                    algo: this.algo
                }

                if (!opts.iv_and_e)
                    result.iv = opts.iv;

                if (tag)
                    result.tag = tag;

                resolve(result);
                cipherText.fill(0);
            }, err => reject(`AES wrap key: CryptoSubtle error (${err}).`));
        });
    }

    /**
     * Unwraps another AES key using this one; resulting key is AES-CBC.
     * @param   wrapped The wrapped key to decrypt.
     * @param   opts    Unwrapping options.
     * @returns         A promise fulfilling with the unwrapped key.
     */
    public unwrapAESKey(wrapped: Uint8Array, opts?: AESUnwrapOptions): Promise<AESKey> {
        return new Promise((resolve, reject) => {
            opts = opts || {};

            if (!opts.iv) {
                opts.iv = wrapped.subarray(0, AES_IV_LENGTH);
                wrapped = wrapped.subarray(AES_IV_LENGTH);
            }

            let decryptOpts: any = {
                name: this.algo,
                iv: opts.iv.buffer
            };

            if (opts.tag) {
                wrapped = concat(wrapped, opts.tag);
                decryptOpts.tagLength = opts.tag.byteLength;
            } else if (this.algo === "AES-GCM") {
                throw new Error("no tag provided for AES-GCM unwrapping")
            }

            crypto.subtle.unwrapKey("raw", wrapped.buffer, this.key, decryptOpts, {
                name: opts.algo || "AES-CBC"
            } as any, opts.exportable ? true : false, [
                "encrypt",
                "decrypt",
                "wrapKey",
                "unwrapKey"
            ]).then(
                unwrapped => resolve(new AESKey(unwrapped)),
                err => reject(`AES unwrap key: CryptoSubtle error (${err}).`)
            );
        });
    }

    public export(): Promise<Uint8Array> {
        return new Promise((resolve, reject) => {
            crypto.subtle.exportKey("raw", this.key).then(
                raw => resolve(new Uint8Array(raw)),
                err => reject(`AES export key: CryptoSubtle error (${err}).`)
            );
        });
    }

    constructor(key: CryptoKey) {
        this.key = key;
        this.algo = key.algorithm.name as AESAlgorithm;
    }

}