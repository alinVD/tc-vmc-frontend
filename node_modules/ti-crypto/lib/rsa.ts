// Copyright 2017 Tera Insights, LLC. All rights reserved.

import {base64ToBytes, bytesToBase64, randomBytes, bytesToHex} from "./misc"
import {AESKey} from "./aes";
import {
    DERBlock,
    decodeBase256Integer,
    decodeDER,
    encodeToDER,
    unsigned,
    concat,
    EOC,
    INTEGER,
    BIT_STR,
    OCT_STR,
    SEQUENCE
} from "./der"

declare class TextDecoder {
    decode(bin: ArrayBufferView): string;
    constructor(enc?: string);
}

export type Hash = "SHA-1"|"SHA-256"|"SHA-512";

export interface Signature {
    signature: string;  // Base64-encoded signature.
    saltLength: number; // Length of salt used for RSA-PSS, in bytes.
}

export interface ChallengeSignature {
    signature:   string;
    serverToken: string;
    clientToken: string;
    saltLen:     number;
    challID?:    any;
    mfaTokens?:  any[];
}

export interface RSAKeyPair {
    public:  RSAPublic;  // RSA public key (verify, encrypt, wrap AES keys).
    private: RSAPrivate; // RSA private key (sign, decrypt, unwrap AES keys).
}

export interface ExternalRSAPublic {
    modulus:        string; // Base64-encoded modulus.
    publicExponent: string; // Base64-encoded public exponent.
}

export interface ExternalRSAPrivate {
    encrypted: string;           // Encrypted private key, encoded to Base64.
    encoding:  "pkcs8";          // Private key format.
    kdf:       "PBKDF2:SHA-256"; // Key derivation function and hash used for derivation, colon-separated.
    rounds:    number;           // Number of hash iterations for deriving encryption key.
    salt?:     string;           // Salt used for deriving encryption key, may be cached on the server.
    encAlgo:   "AES-CBC";        // Encryption key algorithm.
    encSize:   32;               // Encryption key size, in bytes.
    iv?:       string;           // Encryption IV, may be cached on the server.
}

export interface ExternalRSAKeyPair {
    public:  ExternalRSAPublic;  // Modulus and public exponent.
    private: ExternalRSAPrivate; // Encrypted private key.
}

/**
 * This is the old external key format. Keys in this format should be
 * converted and the user should be prompted to download the new format.
 * @deprecated
 */
export interface OldExternalRSAKeyPair {
    publicKey: ExternalRSAPublic;         // Public key (format hasn't changed).
    privateKey: {
        key:        OldWrappedRSAPrivate; // The wrapped private key, described below.
        padding:    boolean;              // Was padding used when wrapping?
        iterations: number;               // Number of rounds of Sha-256 used to derive wrapping key.
        salt?:      string;               // Salt used to derive wrapping key.
        iv?:        string;               // IV used to wrap the private.
    };
}

/**
 * JSON array of the following elements, stringified, then encrypted using AES-CBC
 * and finally encoded to Base64.
 * @deprecated
 * 
 *      Base64-encoded modulus          -- n
 *      Base64-encoded public exponent  -- e
 *      Base64-encoded private exponent -- d
 *      Base64-encoded prime #1         -- p
 *      Base64-encoded prime #2         -- q
 *      Base64-encoded exponent #1      -- d % (p - 1)
 *      Base64-encoded exponent #2      -- d % (q - 1)
 *      Base64-encoded coefficient      -- 1/q - % p
 */
export type OldWrappedRSAPrivate = string

const RSA_VERSION = new Uint8Array([0x02, 0x01, 0x00]);
const RSA_ALGO_ID = new Uint8Array([
    0x30, 0x0D, 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86,
    0xF7, 0x0D, 0x01, 0x01, 0x01, 0x05, 0x00
]);

/**
 * Converts an original tiCrypt key to the updated format.
 * @param   old The deprecated external key JSON to convert.
 * @param   pwd The password to decrypt the old private key format with. Wiped after use.
 * @returns     The re-exported key pair in the new format.
 */
export function convertOldKeyPair(old: OldExternalRSAKeyPair, pwd: Uint8Array): Promise<ExternalRSAKeyPair> {
    return new Promise<ExternalRSAKeyPair>((resolve, reject) => {
        let oldWrapped = base64ToBytes(old.privateKey.key);
        let salt = base64ToBytes(old.privateKey.salt);
        let rounds = old.privateKey.iterations;
        let iv = base64ToBytes(old.privateKey.iv);

        crypto.subtle.importKey("raw", pwd.buffer, {
            name: "PBKDF2"
        }, false, ["deriveKey"]).then(
            derivationKey => {
                pwd.fill(0); // scrub the password
                crypto.subtle.deriveKey({
                    name: "PBKDF2",
                    salt: salt.buffer,
                    iterations: rounds,
                    hash: {name: "SHA-256"}
                }, derivationKey, {
                    name: "AES-CBC",
                    length: 256,
                }, false, ["encrypt", "decrypt"]).then(
                    aesKey => {
                        crypto.subtle.decrypt({
                            name: "AES-CBC",
                            iv: iv.buffer
                        }, aesKey, oldWrapped.buffer).then(
                            oldUnwrapped => {
                                let decoder = new TextDecoder("utf-8");
                                let keyJson: string[] = JSON.parse(decoder.decode(new Uint8Array(oldUnwrapped)));
                                let keyInts = keyJson.map(elem => encodeToDER(INTEGER, unsigned(base64ToBytes(elem))));
                                keyInts.unshift(new Uint8Array([0x02, 0x01, 0x00]));
                                
                                let privateKey = encodeToDER(OCT_STR, encodeToDER(SEQUENCE, concat(...keyInts)))
                                let pkcs8Key = encodeToDER(SEQUENCE, concat(RSA_VERSION, RSA_ALGO_ID, privateKey));

                                // Change the IV and re-encrypt (PKCS8 this time).
                                iv = randomBytes(16);
                                crypto.subtle.encrypt({
                                    name: "AES-CBC",
                                    iv: iv.buffer
                                }, aesKey, pkcs8Key.buffer).then(
                                    wrapped => resolve({
                                        public: old.publicKey,
                                        private: {
                                            encrypted: bytesToBase64(new Uint8Array(wrapped)),
                                            encoding: "pkcs8",
                                            kdf: "PBKDF2:SHA-256",
                                            rounds: rounds,
                                            salt: bytesToBase64(salt),
                                            encAlgo: "AES-CBC",
                                            encSize: 32,
                                            iv: bytesToBase64(iv)
                                        }
                                    }),
                                    err => reject(`CryptoSubtle failed to rewrap key (${err}).`)
                                );
                            },
                            err => reject(`CryptoSubtle failed to unwrap key (${err}).`)
                        );
                    },
                    err => reject(`CryptoSubtle failed to derive unwrapping/re-wrapping key (${err}).`)
                );
            },
            err => reject(`CryptoSubtle failed to create derivation key from password (${err}).`)
        );
    }).catch(err => { throw new Error(`RSA convert deprecated key pair: ${err}`); });
}

/**
 * Converts an 8-part binary asmCrypto private key to a tiCrypto keypair which uses
 * the specified hash for all operations.
 * @param asmKey The asmCrypto private key.
 * @param hash The SHA algorithm for the resulting keypair.
 * @param exportable Whether or not the converted public and private should be exportable.
 */
export function importASMCryptoRSA(asmKey: Uint8Array[], hash: Hash, exportable?: boolean): Promise<RSAKeyPair> {
    let keyParts = asmKey.map(elem => encodeToDER(INTEGER, unsigned(elem)));
    keyParts.unshift(new Uint8Array([0x02, 0x01, 0x00]));
    
    let keyBuff = encodeToDER(OCT_STR, encodeToDER(SEQUENCE, concat(...keyParts)))
    let pkcs8Key = encodeToDER(SEQUENCE, concat(RSA_VERSION, RSA_ALGO_ID, keyBuff));

    return Promise.all([
        crypto.subtle.importKey("pkcs8", pkcs8Key, {
            name: "RSA-PSS",
            hash: { name: hash }
        }, exportable || false, ["decrypt", "unwrapKey"]),
        crypto.subtle.importKey("pkcs8", pkcs8Key, {
            name: "RSA-OAEP",
            hash: { name: hash }
        }, exportable || false, ["decrypt", "unwrapKey"])
    ]).then(([pss, oaep]) => {
        let priv = new RSAPrivate(pss, oaep);
        return priv.extractPublic().then(pub => {
            return {
                public: pub,
                private: priv
            };
        });
    });
}

/**
 * Generates and exports a new RSA key pair, wrapping the private.
 * @param   modLen The desired modulus length, in bits; defaults to 2048.
 * @param   pubExp The desired public exponent; defaults to [0x01, 0x00, 0x01] (65,537).
 * @returns        A promise fulfilling with an external key pair.
 */
export function genRSAKeyPair(modLen?: 1024|2048|4096, pubExp?: Uint8Array): Promise<RSAKeyPair> {
    return new Promise((resolve, reject) => {
        crypto.subtle.generateKey({
            name: "RSA-PSS",
            modulusLength: modLen || 2048,
            publicExponent: pubExp || new Uint8Array([0x01, 0x00, 0x01]),
            hash: {name: "SHA-256"}
        }, true, ["sign", "verify"]).then(
            pssPair => {
                Promise.all([
                    crypto.subtle.exportKey("spki", pssPair.publicKey),
                    crypto.subtle.exportKey("pkcs8", pssPair.privateKey)
                ]).then(
                    ([rawPub, rawPriv]) => {
                        const algo = {
                            name: "RSA-OAEP",
                            hash: {name: "SHA-256"}
                        } as AlgorithmIdentifier;
                        Promise.all([
                            crypto.subtle.importKey("spki", rawPub, algo, true, ["encrypt", "wrapKey"]),
                            crypto.subtle.importKey("pkcs8", rawPriv, algo, true, ["decrypt", "unwrapKey"])
                        ]).then(
                            ([oaepPub, oaepPriv]) => {
                                new Uint8Array(rawPriv).fill(0);
                                resolve({
                                    public: new RSAPublic(pssPair.publicKey, oaepPub),
                                    private: new RSAPrivate(pssPair.privateKey, oaepPriv)
                                });
                            },
                            err => reject(`RSA gen key: CryptoSubtle failed to re-import keys as OAEP (${err}).`)
                        );
                    },
                    err => reject(`RSA gen key: CryptoSubtle failed to export raw keys (${err}).`)
                );
            },
            err => reject(`RSA gen key: CryptoSubtle error (${err}).`)
        );
    });
};

/**
 * Generates and exports a new RSA key pair, wrapping the private.
 * @param   pwd    The password to wrap the private with. Wiped after use.
 * @param   modLen The desired modulus length, in bits; defaults to 2048.
 * @param   pubExp The desired public exponent; defaults to [0x01, 0x00, 0x01] (65,537).
 * @returns        A promise fulfilling with an external key pair.
 */
export function genRSAKeyPairAndExport(pwd: Uint8Array, modLen?: 1024|2048|4096,
        pubExp?: Uint8Array): Promise<ExternalRSAKeyPair> {
    return new Promise((resolve, reject) => {
        crypto.subtle.generateKey({
            name: "RSA-PSS",
            modulusLength: modLen || 2048,
            publicExponent: pubExp || new Uint8Array([0x01, 0x00, 0x01]),
            hash: {name: "SHA-256"}
        }, true, ["sign", "verify"]).then(
            keyPair => {
                exportRSAPrivate(keyPair.privateKey, pwd).then(
                    extPriv => {
                        exportRSAPublic(keyPair.publicKey).then(
                            extPub => resolve({
                                public: extPub,
                                private: extPriv
                            }),
                            err => reject(`RSA gen key: ${err}`)
                        );
                    },
                    err => reject(`RSA gen key: ${err}`)
                );
            },
            err => reject(`RSA gen key: CryptoSubtle error (${err}).`)
        );
    });
};

/**
 * Imports an RSA key pair, unwrapping the private key using a given password.
 * Once both keys have been imported, the successful private key decryption is
 * checked by signing random data with the private and verifying with the public.
 * @param   ext The external key pair, usually read from file.
 * @param   pwd The password used to decrypt the private, wiped after use.
 * @returns     An RSA key pair ready for use.
 */
export function importRSAKeyPair(ext: ExternalRSAKeyPair, pwd: Uint8Array): Promise<RSAKeyPair> {
    return Promise.all([
        importRSAPublic(ext.public),
        importRSAPrivate(ext.private, pwd)
    ]).then(([pubkey, privKey]) => {
        return {
            public: pubkey,
            private: privKey
        };
    });
}

/**
 * A wrapper holding two CryptoSubtle imports of the same RSA public
 * key so that we can use PSS and OAEP functions from the same object.
 * 
 * @author Sam Claus
 * @version 9/26/17
 * @copyright Tera Insights, LLC.
 */
export class RSAPublic {

    public readonly pss: CryptoKey;  // "verify"
    public readonly oaep: CryptoKey; // "encrypt", "wrapKey"

    public verify(data: Uint8Array, sig: Signature): Promise<boolean> {
        return new Promise((resolve, reject) => {
            crypto.subtle.verify({
                name: "RSA-PSS",
                saltLength: sig.saltLength
            }, this.pss, base64ToBytes(sig.signature).buffer, data.buffer).then(
                resolve,
                err => reject(`RSA verify: CryptoSubtle error (${err}).`)
            );
        });
    }

    public encrypt(clearText: Uint8Array): Promise<Uint8Array> {
        return new Promise((resolve, reject) => {
            crypto.subtle.encrypt({
                name: "RSA-OAEP",
            }, this.oaep, clearText.buffer).then(
                encrypted => resolve(new Uint8Array(encrypted)),
                err => reject(new Error(`RSA encrypt: CryptoSubtle error (${err}).`))
            );
        });
    }

    public wrapAESKey(key: AESKey): Promise<Uint8Array> {
        return new Promise((resolve, reject) => {
            if (!key.key.extractable)
                throw new Error("AES key cannot be wrapped because it is not exportable.");

            crypto.subtle.wrapKey("raw", key.key, this.oaep, {
                name: "RSA-OAEP",
                hash: {name: "SHA-256"}
            } as AlgorithmIdentifier).then(
                wrapped => resolve(new Uint8Array(wrapped)),
                err => reject(`RSA wrap key: CryptoSubtle error (${err})`)
            );
        });
    }

    public export(): Promise<ExternalRSAPublic> {
        return exportRSAPublic(this.pss);
    }

    constructor(pss: CryptoKey, oaep: CryptoKey) {
        this.pss = pss;
        this.oaep = oaep;
    }

}

/**
 * A wrapper holding two CryptoSubtle imports of the same RSA private
 * key so that we can use PSS and OAEP functions from the same object.
 * 
 * @author Sam Claus
 * @version 9/26/17
 * @copyright Tera Insights, LLC.
 */
export class RSAPrivate {

    private pss: CryptoKey;  // "sign"
    private oaep: CryptoKey; // "decrypt", "unwrapKey"

    public sign(data: Uint8Array, saltLen?: number): Promise<Signature> {
        return new Promise((resolve, reject) => {
            saltLen = saltLen ? saltLen : 32;
            crypto.subtle.sign({
                name: "RSA-PSS",
                saltLength: saltLen
            }, this.pss, data.buffer).then(
                sig => resolve({
                    signature: bytesToBase64(new Uint8Array(sig)),
                    saltLength: saltLen
                }),
                err => reject(new Error(`RSA sign: CryptoSubtle error (${err}).`))
            );
        });
    }

    /**
     * Generates a client token and signs it together with
     * a challenge from the server.
     * @param   challenge Base64-encoded challenge.
     * @param   saltLen   Length of salt to generate, in bytes; default is 32.
     * @returns           The signature, client token, etc.
     */
    public signChallenge(challenge: string, saltLen?: number): Promise<ChallengeSignature> {
        return new Promise((resolve, reject) => {
            let serverToken = base64ToBytes(challenge);
            let clientToken = randomBytes(32);

            let dataToSign = new Uint8Array(serverToken.length + clientToken.length);
            dataToSign.set(serverToken, 0);
            dataToSign.set(clientToken, serverToken.length);

            this.sign(dataToSign, saltLen).then(sig => resolve({
                signature: sig.signature,
                serverToken: challenge,
                clientToken: bytesToBase64(clientToken),
                saltLen: sig.saltLength
            }), reject);
        });
    }

    public decrypt(cipherText: Uint8Array): Promise<Uint8Array> {
        return new Promise((resolve, reject) => {
            crypto.subtle.decrypt({
                name: "RSA-OAEP"
            }, this.oaep, cipherText.buffer).then(
                clearText => resolve(new Uint8Array(clearText)),
                err => reject(`RSA decrypt: CryptoSubtle error (${err}).`)
            );
        });
    }

    /**
     * Unwraps an encrypted AES key.
     * @param wrapped    The encrypted key.
     * @param algo       The algorithm the key will be used with (once unwrapped.)
     * @param exportable Whether or not the unwrapped key should be re-exportable
     *                   from CryptoSubtle.
     * @returns          An AES key with CryptoSubtle functionality.
     */
    public unwrapAESKey(wrapped: Uint8Array, algo: "AES-CBC"|"AES-GCM", exportable?: boolean): Promise<AESKey> {
        return new Promise((resolve, reject) => {
            crypto.subtle.unwrapKey("raw", wrapped.buffer, this.oaep, {
                name: "RSA-OAEP",
                hash: {name: "SHA-256"}
            } as any, {
                name: algo
            } as any, exportable ? true : false, ["encrypt", "decrypt", "wrapKey", "unwrapKey"]).then(
                unwrapped => resolve(new AESKey(unwrapped)),
                err => reject(`RSA unwrap key: CryptoSubtle error (${err}).`)
            );
        });
    }

    public export(password: Uint8Array, rounds?: number): Promise<ExternalRSAPrivate> {
        return exportRSAPrivate(this.pss, password, rounds);
    }

    public extractPublic(): Promise<RSAPublic> {
        return new Promise<RSAPublic>((resolve, reject) => {
            crypto.subtle.exportKey("pkcs8", this.pss).then(
                pkcs8 => {
                    let keySeq = decodeDER(decodeDER(decodeDER(decodeDER(decodeDER(
                        new Uint8Array(pkcs8)).content).remaining).remaining).content).content;
                    let rsaVersion = decodeDER(keySeq);
                    let nBlock = decodeDER(rsaVersion.remaining);
                    let eBlock = decodeDER(nBlock.remaining);
                    let spki = makeSPKI(nBlock.content, eBlock.content);

                    Promise.all([
                        crypto.subtle.importKey("spki", spki.buffer, {
                            name: "RSA-PSS",
                            hash: {name: "SHA-256"}
                        }, true, ["verify"]),
                        crypto.subtle.importKey("spki", spki.buffer, {
                            name: "RSA-OAEP",
                            hash: {name: "SHA-256"}
                        }, true, ["encrypt", "wrapKey"])
                    ]).then(
                        ([pss, oaep]) => {
                            resolve(new RSAPublic(pss, oaep));
                            new Uint8Array(pkcs8).fill(0);
                        },
                        err => {
                            reject(`CryptoSubtle failed to import SPKI public key (${err}).`);
                            new Uint8Array(pkcs8).fill(0);
                        }
                    );
                },
                err => reject(`CryptoSubtle failed to export private to PKCS8 (${err}).`)
            );
        }).catch(err => { throw new Error(`RSA extract public: ${err}`); });
    }

    /**
     * Loads an RSA private key from an encrypted external format.
     * @param pss The private key, loaded for signing.
     * @param oaep The private key, loaded for decryption and unwrapping.
     */
    constructor(pss: CryptoKey, oaep: CryptoKey) {
        this.pss = pss;
        this.oaep = oaep;
    }

}

/**
 * Reads an RSA public JSON, encodes the modulus and public exponent to SPKI,
 * and finally imports the key into CryptoSubtle.
 * @param   ext The external public key JSON.
 * @returns     An RSA public key with CryptoSubtle functionality.
 */
export function importRSAPublic(ext: ExternalRSAPublic): Promise<RSAPublic> {
    return new Promise((resolve, reject) => {
        let spki = externalRSAPublicToSPKI(ext);
        Promise.all([
            crypto.subtle.importKey("spki", spki.buffer, {
                name: "RSA-PSS",
                hash: {name: "SHA-256"}
            }, true, ["verify"]),
            crypto.subtle.importKey("spki", spki.buffer, {
                name: "RSA-OAEP",
                hash: {name: "SHA-256"}
            }, true, ["encrypt", "wrapKey"])
        ]).then(
            ([pss, oaep]) => resolve(new RSAPublic(pss, oaep)),
            err => reject(new Error(`RSA import public: CryptoSubtle error (${err}).`))
        );
    });
}

/**
 * Reads an external RSA private key JSON, decrypts the key using the included options,
 * and imports the private into CryptoSubtle.
 * @param   ext The external private key JSON.
 * @param   pwd The password to derive the AES decryption key with.
 * @returns     An RSA private key with CryptoSubtle functionality.
 */
export function importRSAPrivate(ext: ExternalRSAPrivate, pwd: Uint8Array): Promise<RSAPrivate> {
    return new Promise<RSAPrivate>((resolve, reject) => {
        crypto.subtle.importKey("raw", pwd.buffer, {
            name: "PBKDF2"
        }, false, ["deriveKey"]).then(
            derivationKey => {
                pwd.fill(0);
                let kdfAndHash = ext.kdf.split(":");
                crypto.subtle.deriveKey({
                    name: kdfAndHash[0],
                    salt: base64ToBytes(ext.salt).buffer,
                    iterations: ext.rounds,
                    hash: {name: kdfAndHash[1]}
                }, derivationKey, {
                    name: ext.encAlgo,
                    length: ext.encSize * 8,
                }, false, ["unwrapKey"]).then(
                    decryptionKey => {
                        let encryptedPrivate = base64ToBytes(ext.encrypted);
                        let iv = base64ToBytes(ext.iv).buffer;
                        Promise.all([
                            crypto.subtle.unwrapKey(ext.encoding, encryptedPrivate,
                                decryptionKey, {
                                    name: ext.encAlgo,
                                    iv: iv
                                } as any, {
                                    name: "RSA-PSS",
                                    hash: {name: "SHA-256"}
                                } as any, false, ["sign"]),
                            crypto.subtle.unwrapKey(ext.encoding, encryptedPrivate,
                                decryptionKey, {
                                    name: ext.encAlgo,
                                    iv: iv
                                } as any, {
                                    name: "RSA-OAEP",
                                    hash: {name: "SHA-256"}
                                } as any, false, ["decrypt", "unwrapKey"])
                        ]).then(
                            ([pss, oaep]) => {
                                resolve(new RSAPrivate(pss, oaep));
                            },
                            err => reject(`CryptoSubtle failed to unwrap key (${err}).`)
                        );
                    },
                    err => reject(`CryptoSubtle failed to derive unwrapping key (${err}).`)
                );
            },
            err => reject(`CryptoSubtle failed to create derivation key from password (${err}).`)
        );
    }).catch(err => { throw new Error(`RSA import private: ${err}`) });
}

/**
 * Exports a CryptoSubtle public key to JSON.
 * @param   key Opaque CryptoSubtle key reference; must be extractable.
 * @returns     An RSA public key JSON.
 */
function exportRSAPublic(key: CryptoKey): Promise<ExternalRSAPublic> {
    return new Promise((resolve, reject) => {
        crypto.subtle.exportKey("spki", key).then(
            spki => resolve(spkiToExternalRSAPublic(new Uint8Array(spki))),
            err => reject(`RSA export public: CryptoSubtle error (${err}).`)
        );
    });
}

/**
 * Exports an RSA private key, wrapping the key.
 * @param key    Opaque CryptoSubtle key reference.
 * @param pwd    The password to create the encryption key from.
 * @param rounds The rounds of SHA-256 to use when deriving the encryption key.
 * @returns      An RSA private key JSON containing the encrypted private and all
 *               the options used to encrypt it (excluding the password, of course).
 */
function exportRSAPrivate(key: CryptoKey, pwd: Uint8Array, rounds?: number): Promise<ExternalRSAPrivate> {
    return new Promise<ExternalRSAPrivate>((resolve, reject) => {
        let salt = randomBytes(16);
        let iv = randomBytes(16);
        rounds = rounds || 20000;

        crypto.subtle.importKey("raw", pwd.buffer, {name: "PBKDF2"}, false, ["deriveKey"]).then(
            derivationKey => {
                pwd.fill(0);
                crypto.subtle.deriveKey({
                    name: "PBKDF2",
                    salt: salt.buffer,
                    iterations: rounds,
                    hash: {name: "SHA-256"}
                }, derivationKey, {
                    name: "AES-CBC",
                    length: 256,
                }, false, ["wrapKey"]).then(
                    wrappingKey => {
                        crypto.subtle.wrapKey("pkcs8", key, wrappingKey, {
                            name: "AES-CBC",
                            iv: iv.buffer
                        } as AlgorithmIdentifier).then(
                            wrappedPrivate => {
                                resolve({
                                    encrypted: bytesToBase64(new Uint8Array(wrappedPrivate)),
                                    encoding: "pkcs8",
                                    kdf: "PBKDF2:SHA-256",
                                    rounds: rounds,
                                    salt: bytesToBase64(salt),
                                    encAlgo: "AES-CBC",
                                    encSize: 32,
                                    iv: bytesToBase64(iv)
                                });
                            },
                            err => reject(`CryptoSubtle failed to wrap key (${err}).`)
                        );
                    },
                    err => reject(`CryptoSubtle failed to derive wrapping key (${err}).`)
                );
            },
            err => reject(`CryptoSubtle failed to create derivation key from password (${err}).`)
        );
    }).catch(err => { throw new Error(`RSA export private: ${err}`) });
}

/**
 * Decodes an SPKI public key and puts it into a more manageable JSON format.
 * SPKI has little to no documentation and I'm not actually sure the spec has
 * been finished, but the browsers all encode to this ASN.1 structure:
 * 
 * SEQUENCE                     -- The root sequence
 *      SEQUENCE                -- The key algorithm
 *          OBJECT IDENTIFIER   -- 1.2.840.113549.1.1.1 (RSA PKCS1)
 *          ANY (OPTIONAL)      -- Special algorithm params (NULL for RSA)
 *      BIT STRING              -- Public key bit string wrapper
 *          EOC                 -- Standalone 0 (EOC) byte (why though??)
 *          SEQUENCE            -- Public key sequence
 *              INTEGER         -- Modulus (n)
 *              INTEGER         -- Public exponent (e)
 * 
 * @param   spki The RSA public key, in SPKI format (see above).
 * @returns      A public key JSON.
 */
function spkiToExternalRSAPublic(spki: Uint8Array): ExternalRSAPublic {
    let rootSeq = decodeDER(spki);
    let keyAlgo = decodeDER(rootSeq.content);
    let bitStr = decodeDER(keyAlgo.remaining);
    let pubKey = decodeDER(bitStr.content.slice(1)); // cut out the EOC byte
    let modulus = decodeDER(pubKey.content);
    let publicExponent = decodeDER(modulus.remaining);

    return {
        modulus: bytesToBase64(modulus.content),
        publicExponent: bytesToBase64(publicExponent.content)
    };
}

/**
 * Reads the modulus and public exponent from an RSA public key JSON and
 * encodes them to an SPKI key representation (see spkiToExternalRSAPublic).
 * @param   ext The public key JSON.
 * @returns     A binary SPKI public key.
 */
function externalRSAPublicToSPKI(ext: ExternalRSAPublic): Uint8Array {
    return makeSPKI(base64ToBytes(ext.modulus), base64ToBytes(ext.publicExponent));
}

/**
 * Takes the two parts of an RSA public key and forms an SPKI structure.
 * @param   n Modulus, 0 will be prepended if it is signed (i.e. negative).
 * @param   e Public exponent.
 * @returns   Public key in SPKI format.
 */
function makeSPKI(n: Uint8Array, e: Uint8Array): Uint8Array {
    n = encodeToDER(INTEGER, unsigned(n));
    e = encodeToDER(INTEGER, unsigned(e));

    let pubKey = encodeToDER(SEQUENCE, concat(n, e));

    // For whatever reason, we have to prefix EOC byte.
    let preEOC = new Uint8Array(1 + pubKey.length);
    preEOC[0] = EOC;
    preEOC.set(pubKey, 1);

    const rsaAlgoID = new Uint8Array([
        0x30, 0x0D, 0x06, 0x09, 0x2A, 0x86, 0x48, 0x86,
        0xF7, 0x0D, 0x01, 0x01, 0x01, 0x05, 0x00
    ]);
    let bitStr = encodeToDER(BIT_STR, preEOC);

    return encodeToDER(SEQUENCE, concat(rsaAlgoID, bitStr));
}