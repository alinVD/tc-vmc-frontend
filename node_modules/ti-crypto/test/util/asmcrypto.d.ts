declare var asmCrypto: asmCrypto.IAsmCryptoStatic;

declare module 'asmCrypto' {
    export = asmCrypto;
}

type Buffer = string|ArrayBuffer|Uint8Array;

declare module asmCrypto {
    interface IAES_CBSStatic {
        encrypt(data: Buffer, key: Buffer,
            padding: boolean, iv: Buffer): Uint8Array;
        decrypt(data: Buffer, key: Buffer,
            padding: boolean, iv: Buffer): Uint8Array;
    }

    interface IPBKDF2_HMAC_SHA256Static {
        bytes(pwd: Buffer, salt: Uint8Array, iter: number, dklen: number): Uint8Array;
    }

    interface IRSAStatic {
        generateKey(bitlen: number, pubexp: number): Uint8Array[];
    }

    interface IRSA_PSSStatic {
        sign(data: Buffer, key: Uint8Array[], slen: number): Uint8Array;
        verify(signature: Buffer, data: Buffer, key: Uint8Array[], slen: number): boolean
    }

    interface IRSA_OAEP_SHA256 {
        encrypt(data: Buffer, pubKey: Uint8Array[]): Uint8Array;
        decrypt(data: Buffer, prvKey: Uint8Array[]): Uint8Array; 
    }

    interface ISHA256 {
        base64(data: Buffer): string;
        bytes(data: Buffer): Uint8Array;
        hex(data: Buffer): string;
    }

    export interface IAsmCryptoStatic {
        bytes_to_hex(val: Uint8Array): string;
        hex_to_bytes(val: string): Uint8Array;

        bytes_to_base64(val: Uint8Array): string;
        base64_to_bytes(val: string): Uint8Array;

        bytes_to_string(val: Uint8Array): string;
        string_to_bytes(val: string): Uint8Array;

        localstring_to_bytes(val: string): Uint8Array;

        getRandomValues(val: Uint8Array): void;
        random : {
            (): number;
            seed: (seed: Uint8Array) => void;
            skipSystemRNGWarning: boolean;
        }; 

        AES_CBC: IAES_CBSStatic;
        PBKDF2_HMAC_SHA256: IPBKDF2_HMAC_SHA256Static;
        RSA: IRSAStatic;
        RSA_PSS_SHA256: IRSA_PSSStatic;
        RSA_OAEP_SHA256: IRSA_OAEP_SHA256;
        SHA256: ISHA256;
    }
}