/// <reference path="../node_modules/@types/mocha/index.d.ts" />
/// <reference path="util/asmcrypto.d.ts" />

/**
 * Tests for the tiCrypto RSA functionality..
 * 
 * @author Sam Claus
 * @version 10/5/17
 * @copyright Tera Insights, LLC.
 */

import {
    ChallengeSignature,
    convertOldKeyPair,
    ExternalRSAKeyPair,
    ExternalRSAPrivate,
    ExternalRSAPublic,
    genAESKey,
    genRSAKeyPair,
    genRSAKeyPairAndExport,
    importRSAKeyPair,
    importRSAPrivate,
    importRSAPublic,
    OldExternalRSAKeyPair,
    randomBytes,
    RSAKeyPair,
    RSAPrivate,
    RSAPublic,
    Signature,
} from "../src";
import {testEncryptDecrypt} from "./util/_util";
import {expect} from "chai";
import * as chaiAsync from "chai-as-promised";
import * as sinon from "sinon";

asmCrypto.random.skipSystemRNGWarning = true;

declare class TextEncoder {
    encode(text: string): Uint8Array;
}

function generateDeprecated(email: string, pwd: Uint8Array): OldExternalRSAKeyPair {
    let key = asmCrypto.RSA.generateKey(2048, 65537);

    let salt = new Uint8Array(16);
    let iterations = 20000;
    let iv = new Uint8Array(16);

    asmCrypto.getRandomValues(salt);
    asmCrypto.getRandomValues(iv);

    let pbkdf2 = asmCrypto.PBKDF2_HMAC_SHA256.bytes(pwd, salt, iterations, 32);
    let b64Key = key.map(asmCrypto.bytes_to_base64);
    let keyJson = JSON.stringify(b64Key);
    let rawJson = asmCrypto.string_to_bytes(keyJson);
    let encPriv = asmCrypto.AES_CBC.encrypt(rawJson, pbkdf2, true, iv);

    return {
        email: email,
        key: {
            publicKey: {
                modulus: asmCrypto.bytes_to_base64(key[0]),
                publicExponent: asmCrypto.bytes_to_base64(key[1])
            },
            privateKey: {
                key: asmCrypto.bytes_to_base64(encPriv),
                salt: asmCrypto.bytes_to_base64(salt),
                iv: asmCrypto.bytes_to_base64(iv),
                iterations: iterations,
                padding: true
            }
        }
    };
}

describe("RSA Crypto", function() {
    let password = randomBytes(24);
    let deprecatedPair = generateDeprecated("fake@nonexistent.net", password.slice());
    let extKeyPair: ExternalRSAKeyPair;

    it("should convert old key pair to new format", function() {
        return convertOldKeyPair(deprecatedPair, password.slice()).then(pair => extKeyPair = pair);
    });

    it("should import a key pair", function() {
        return importRSAKeyPair(extKeyPair, password.slice());
    });

    let pubKey: RSAPublic;
    let privKey: RSAPrivate;

    it("should generate a key pair", function() {
        return genRSAKeyPair(2048).then(keyPair => {
            pubKey = keyPair.public;
            privKey = keyPair.private;
        });
    });

    it("should sign then verify", function() {
        let data = randomBytes(256 + Math.floor(Math.random() * 4000));
        return privKey.sign(data).then(signature => {
            return pubKey.verify(data, signature).then(valid => {
                expect(valid).to.be.true;
            });
        });
    });

    it("should encrypt then decrypt", function() {
        let data = randomBytes(64);
        return pubKey.encrypt(data).then(cipherText => {
            return privKey.decrypt(cipherText).then(clearText => {
                expect(clearText).to.deep.equal(data);
            });
        });
    });

    it("should wrap and unwrap an AES key", function() {
        return genAESKey(32, "AES-CBC").then(aesKey => {
            return pubKey.wrapAESKey(aesKey).then(wrapped => {
                return privKey.unwrapAESKey(wrapped, "AES-CBC", false).then(unwrapped => {
                    return testEncryptDecrypt(unwrapped, aesKey);
                });
            });
        });
    });
});