/// <reference path="../node_modules/@types/mocha/index.d.ts" />

/**
 * Tests for the tiCrypto AES describe.
 * 
 * @author Sam Claus
 * @version 10/5/17
 * @copyright Tera Insights, LLC.
 */

import {
    AES_IV_LENGTH,
    AESAlgorithm,
    AESEncryptionResult,
    AESEncryptOptions,
    AESKey,
    base64ToBytes,
    genAESKey,
    genCompositeAESKey,
    importAESKey,
    randomBytes
} from "../src";
import {testEncryptDecrypt} from "./util/_util";
import {expect} from "chai";
import * as chaiAsync from "chai-as-promised";
import * as sinon from "sinon";
import mocha = require("mocha");

describe("AES Crypto", function() {
    let key: AESKey;

    it("should generate a key", function() {
        return genAESKey(32, "AES-CBC").then(generated => key = generated);
    });

    it("should encrypt then decrypt", function() {
        return testEncryptDecrypt(key, key);
    });

    it("should export then import key, then encrypt/decrypt to make sure key is the same", function() {
        return key.export().then(rawKey => {
            return importAESKey(rawKey, "AES-CBC").then(imported => {
                return testEncryptDecrypt(imported, key);
            });
        })
    });

    let anotherKey: AESKey;

    it("should generate a second key, this time AES-GCM", function() {
        return genAESKey(32, "AES-GCM").then(generated => anotherKey = generated);
    });

    it("should wrap and unwrap the second key using the first, then test the unwrapped", function() {
        return key.wrapAESKey(anotherKey).then(result => {
            return key.unwrapAESKey(base64ToBytes(result.cipherText), {
                iv: base64ToBytes(result.iv),
                algo: "AES-GCM"
            }).then(unwrapped => {
                return testEncryptDecrypt(unwrapped, anotherKey);
            });
        });
    });

    it("should generate a composite key", function() {
        return genCompositeAESKey(20, "AES-CBC");
    });
});