/// <reference path="../node_modules/@types/mocha/index.d.ts" />

/**
 * Tests for the tiCrypto miscellaneous utilities.
 * 
 * @author Sam Claus
 * @version 10/5/17
 * @copyright Tera Insights, LLC.
 */

import {
    base64ToBytes,
    bytesToBase64,
    bytesToHex,
    equalBuffers,
    hexToBytes,
    randomBytes,
    randomString,
    sha256,
} from "../src/lib/misc";
import {expect} from "chai";
import * as chaiAsPromised from "chai-as-promised";
import * as sinon from "sinon";

describe("Miscellaneous crypto utilities", function() {

    /**
     * Tests several cases of buffer comparison--identical
     * buffers, buffers of different length, buffers of same
     * length but different values, and finally a filled buffer
     * with a zero-length buffer.
     */
    it("should correctly evaluate buffer equality", function() {
        let buf1 = new Uint8Array([1, 2, 3]);
        let buf2 = new Uint8Array([1, 2, 3]);
        let buf3 = new Uint8Array([1, 2, 3, 4]);
        let buf4 = new Uint8Array([1, 2, 7]);
        let buf5 = new Uint8Array(0);

        expect(equalBuffers(buf1, buf2)).to.equal(true);
        expect(equalBuffers(buf1, buf3)).to.equal(false);
        expect(equalBuffers(buf1, buf4)).to.equal(false);
        expect(equalBuffers(buf1, buf5)).to.equal(false);
    });

    /**
     * Tests using a known buffer and corresponding hash to make
     * sure the CryptoSubtle implementation hashes correctly.
     */
    it("should compute a valid SHA-256 hash", function() {
        return sha256(new Uint8Array([
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
        ])).then(digest => { // zeroed buffer
            expect(digest).to.eql(new Uint8Array([
                0xaf, 0x55, 0x70, 0xf5, 0xa1, 0x81, 0x0b, 0x7a,
                0xf7, 0x8c, 0xaf, 0x4b, 0xc7, 0x0a, 0x66, 0x0f,
                0x0d, 0xf5, 0x1e, 0x42, 0xba, 0xf9, 0x1d, 0x4d,
                0xe5, 0xb2, 0x32, 0x8d, 0xe0, 0xe8, 0x3d, 0xfc
            ]));
        });
    });

    /**
     * Produce 10 random length buffers of random bytes and test
     * conversion to Base64 and back, with both standard and
     * URL-safe encoding each time.
     */
    it("should encode to Base64 and back", function() {
        for (let i = 0; i < 10; i++) {
            let buf = randomBytes(Math.floor(Math.random() * 100));
            expect(base64ToBytes(bytesToBase64(buf, false))).to.deep.equal(buf);
            expect(base64ToBytes(bytesToBase64(buf, true))).to.deep.equal(buf);
        }
    });

    /**
     * Produce 10 random length buffers of random bytes and test
     * conversion to hex and back.
     */
    it("should encode to hex and back", function() {
        for (let i = 0; i < 10; i++) {
            let buf = randomBytes(Math.floor(Math.random() * 100));
            expect(hexToBytes(bytesToHex(buf))).to.deep.equal(buf);
        }
    })
    
});