// Copyright 2017 Tera Insights, LLC. All rights reserved.

import { randomBytes } from "./misc"

export function genPBKDF2Key(exportable?: boolean): Promise<PBKDF2Key> {
    return new Promise((res, rej) => {
        crypto.subtle.generateKey({
            name: "PBKDF2"
        } as any, exportable || false, ["deriveKey", "deriveBits"]).then(
            key => res(new PBKDF2Key(key as CryptoKey)),
            err => rej(`PBKDF2 gen key: CryptoSubtle error (${err}).`)
        );
    });
}

export function importPBKDF2Key(raw: Uint8Array, exportable?: boolean): Promise<PBKDF2Key> {
    return new Promise((res, rej) => {
        crypto.subtle.importKey("raw", raw.buffer, {
            name: "PBKDF2"
        } as any, exportable || false, ["deriveKey", "deriveBits"]).then(
            key => res(new PBKDF2Key(key)),
            err => rej(`PBKDF2 import key: CryptoSubtle error (${err}).`)
        );
    });
}

export class PBKDF2Key {

    public deriveBytes(
        bytes: number,
        iterations: number,
        hashAlgo: "SHA-1"|"SHA-256"|"SHA-384"|"SHA-512",
        salt?: ArrayBuffer
    ): Promise<Uint8Array> {
        return new Promise((res, rej) => {
            crypto.subtle.deriveBits({
                name: "PBKDF2",
                salt: salt || randomBytes(16).buffer,
                iterations: iterations,
                hash: { name: hashAlgo }
            } as any, this.key, bytes * 8).then(
                buf => res(new Uint8Array(buf)),
                err => rej(`AES deriveBytes: CryptoSubtle error (${err}).`)
            );
        });
    }

    constructor(private key: CryptoKey) {}

}