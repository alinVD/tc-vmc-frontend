// Copyright 2017 Tera Insights, LLC. All rights reserved.

/**
 * ASN.1 DER utilities; only intended for use by other
 * crypto utilities, hence the "_" filename prefix.
 * 
 * @author Sam Claus
 * @version 9/26/17
 * @copyright Tera Insights, LLC.
 */

import {bytesToHex} from "./misc";

export const EOC      = 0x00; // ASN.1 (DER) EOC identifier
export const INTEGER  = 0x02; // ASN.1 (DER) integer identifier
export const BIT_STR  = 0x03; // ASN.1 (DER) bit string identifier
export const OCT_STR  = 0x04; // ASN.1 (DER) octet string identifier
export const SEQUENCE = 0x30; // ASN.1 (DER) sequence identifier

export interface DERBlock {
    type: number;          // Integer DER type (3 are listed above).
    content: Uint8Array;   // The content of this DER block.
    remaining: Uint8Array; // The remaining data in the buffer this block was read from.
}

/**
 * Encodes a buffer as the specified ASN.1 (DER) primitive.
 * @param   type  The ASN.1 (DER) primitive type identifier.
 * @param   buf   The data to encode.
 * @returns       An ASN.1 DER primitive sequence.
 */
export function encodeToDER(type: number, buf: Uint8Array): Uint8Array {
    let primitive: Uint8Array;
    let lenOctets = 1;

    // Figure out if we can encode content length in short form or
    // if long form is necessary, size DER buffer accordingly.
    if (buf.length >= 0x80) {
        let nLenBytes = base256Len(buf.length);
        lenOctets += nLenBytes;

        // type + LF length byte + length bytes + content
        primitive = new Uint8Array(1 + 1 + nLenBytes + buf.length);

        // long form length byte says how many following content length bytes
        primitive[1] = 0x80 + nLenBytes;

        // Base256 representation of content length
        for (let n = buf.length, i = 1 + nLenBytes; n > 0; n = Math.floor(n / 256), i--)
            primitive[i] = n % 256;
    } else {
        // type + SF length byte + content
        primitive = new Uint8Array(1 + 1 + buf.length);

        // short form length byte is the content length
        primitive[1] = buf.length;
    }

    // Content type.
    primitive[0] = type;

    // Content at the end (following type and length octets).
    primitive.set(buf, 1 + lenOctets);

    return primitive;
}

/**
 * Calculates the minimum number of bytes needed to represent
 * val in Base256 (each byte is 256 times as significant as
 * the one immediately to the right of it).
 * @param   val The value to be represented.
 * @returns     The number of bytes necessary to store val.
 */
export function base256Len(val: number): number {
    return Math.ceil(Math.log2(val + 1) / 8);
}

/**
 * Strips away any extra zeroes at the beginning of a big
 * integer, leaving one or prepending one at the beginning
 * if necessary in the case where the leftmost bit of the
 * first nonzero element is set, to make the big integer
 * unsigned for the purpose of DER encoding.
 * @param   int A base-256 big integer binary buffer.
 * @returns     The integer, unsigned and without padding.
 */
export function unsigned(int: Uint8Array): Uint8Array {
    if (int.length == 0)
        throw new Error("Attempted to convert an empty Uint8Array to an unsigned buffer.");

    let firstNonzero = 0;
    while (int[firstNonzero] == 0)
        firstNonzero++
    if (firstNonzero != 0)
        return int[firstNonzero] >= 0x80 ? int.slice(firstNonzero - 1) : int.slice(firstNonzero);
    else
        return int[firstNonzero] >= 0x80 ? new Uint8Array([0, ...int]) : int;
}

/**
 * Concatenates multiple buffers into one.
 * @param   bufs Buffers to concatenate.
 * @returns      A new buffer containing bufs.
 */
export function concat(...bufs: Uint8Array[]): Uint8Array {
    let tLen = 0;
    for (let i = 0; i < bufs.length; i++)
        tLen += bufs[i].length;
    
    let concatenated = new Uint8Array(tLen);
    let offset = 0;
    for (let i = 0; i < bufs.length; i++) {
        concatenated.set(bufs[i], offset);
        offset += bufs[i].length;
    }

    return concatenated;
}

/**
 * Reads a block of DER from a buffer.
 * @param   buf The DER-encoded data to read a value from.
 * @returns     The type and content of the DER block read
 *              from the beginning of buf, as well as the
 *              remaining (trailing) data.
 */
export function decodeDER(buf: Uint8Array): DERBlock {
    /**
     * In DER, 0x00 is an EOC indicator, and never has a
     * length or any content, but other blocks may follow.
     */
    if (buf[0] == 0x00) {
        return {
            type: 0x00,
            content: new Uint8Array(0),
            remaining: buf.slice(1)
        };
    }

    let off = 0;
    let len = 0;

    if (buf[1] > 0x80) {
        off = 2 + (buf[1] - 0x80);
        len = decodeBase256Integer(buf.slice(2, off));
    } else if (buf[1] > 0 && buf[1] < 0x80) {
        off = 2;
        len = buf[1];
    } else {
        throw new Error(`Bad ASN length identifier (${buf[1]}).`);
    }

    return {
        type: buf[0],
        content: buf.slice(off, off + len),
        remaining: buf.slice(off + len)
    };
}

/**
 * Converts a binary Uint8Array to an integer, with each byte--moving
 * from right to left--being 256 times more significant than the last.
 * @param   buf    The Uint8Array to be interpreted as a base256 integer.
 * @param   signed Indicates whether the buffer should be interpreted as a
 *                 signed integer (if the leftmost bit is 1); default is false;
 * @returns        The interpreted integer. Please note that if the value
 *                 represented by buf is greated than Number.MAX_SAFE_INTEGER,
 *                 the value returned will be unreliable.
 */
export function decodeBase256Integer(buf: Uint8Array, signed?: boolean): number {
    if (buf.length == 0)
        return 0;
    
    let value = (buf[0] >= 0x80 && signed) ? -Math.pow(256, buf.length) : 0;
    for (let i = buf.length - 1, sig = 1; i >= 0; i--, sig *= 256)
        value += buf[i] * sig;
    return value;
}